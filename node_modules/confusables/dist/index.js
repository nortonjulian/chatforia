"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clean = exports.checkLNP = exports.characters = exports.obfuscate = exports.remove = exports.confusablesMap = exports.alphabetMap = void 0;
const characters_1 = require("./characters");
Object.defineProperty(exports, "characters", { enumerable: true, get: function () { return characters_1.characters; } });
const util_1 = require("./util");
Object.defineProperty(exports, "checkLNP", { enumerable: true, get: function () { return util_1.checkLNP; } });
Object.defineProperty(exports, "clean", { enumerable: true, get: function () { return util_1.clean; } });
/** The current cache of all the supported alphabet characters  */
exports.alphabetMap = new Map();
/** The current cache of all the supported confusable characters */
exports.confusablesMap = new Map();
for (const [base, alts] of characters_1.characters.entries()) {
    exports.alphabetMap.set(base, [...alts]);
    for (const char of alts) {
        exports.confusablesMap.set(char, base);
    }
}
/**
 * Removes confusable unicode characters from a string.
 * @param str The text to remove confusables from.
 */
function remove(str) {
    if ((0, util_1.checkLNP)(str))
        return str;
    let newStr = '';
    for (const char of (0, util_1.clean)(str)) {
        newStr += exports.confusablesMap.get(char) || char;
    }
    return newStr;
}
exports.remove = remove;
/**
 * Randomly mixes up a string with random confusable characters.
 * @param str The text to obfuscate.
 */
function obfuscate(str) {
    let newStr = '';
    for (const char of str) {
        const charMap = exports.alphabetMap.get(char);
        newStr += charMap ? charMap[Math.floor(Math.random() * charMap.length)] : char;
    }
    return newStr;
}
exports.obfuscate = obfuscate;
exports.default = remove;
//# sourceMappingURL=index.js.map