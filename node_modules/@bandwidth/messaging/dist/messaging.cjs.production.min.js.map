{"version":3,"file":"messaging.cjs.production.min.js","sources":["../src/configuration.ts","../src/http/httpInterceptor.ts","../src/defaultConfiguration.ts","../src/errors/apiError.ts","../src/apiHelper.ts","../src/errors/abortError.ts","../src/fileWrapper.ts","../src/http/httpHeaders.ts","../src/http/queryString.ts","../src/http/httpClient.ts","../src/http/pathTemplate.ts","../src/errors/argumentsValidationError.ts","../src/errors/responseValidationError.ts","../src/http/validate.ts","../src/http/requestBuilder.ts","../src/http/xmlSerialization.ts","../src/client.ts","../src/authentication.ts","../src/errors/messagingExceptionError.ts","../src/models/bandwidthMessage.ts","../src/models/bandwidthMessageItem.ts","../src/models/pageInfo.ts","../src/models/bandwidthMessagesList.ts","../src/models/media.ts","../src/models/priorityEnum.ts","../src/models/messageRequest.ts","../src/controllers/baseController.ts","../src/controllers/apiController.ts"],"sourcesContent":["/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\n/** An interface for all configuration parameters required by the SDK. */\nexport interface Configuration {\n  timeout: number;\n  environment: Environment;\n  baseUrl: string;\n  basicAuthUserName: string;\n  basicAuthPassword: string;\n  unstable_httpClientOptions?: any;\n}\n\n/** Environments available for API */\nexport enum Environment {\n  Production = 'production',\n  Custom = 'custom',\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { HttpContext } from './httpContext';\nimport { HttpRequest } from './httpRequest';\n\n/**\n * Interface for a method that executes an HTTP request and returns the HTTP context.\n *\n * The context contains the HTTP response and the HTTP request (which may or may not be the same\n * as the original HTTP request).\n */\nexport type HttpCallExecutor<T> = (\n  request: HttpRequest,\n  requestOptions: T\n) => Promise<HttpContext>;\n\n/**\n * Interface representing an HTTP interceptor method.\n *\n * HTTP interceptors are used to extend the HTTP call pipeline with new behavior or\n * features.\n *\n * An HTTP interceptor receives an HTTP request. It can modify the\n * HTTP request and then pass it along to the next HTTP interceptor in the chain which\n * then returns an HTTP response. It then returns this HTTP response, after optionally\n * modifying it.\n */\nexport interface HttpInterceptorInterface<T> {\n  (request: HttpRequest, requestOptions: T, next: HttpCallExecutor<T>): Promise<\n    HttpContext\n  >;\n}\n\n/**\n * Calls HTTP interceptor chain\n *\n * @param interceptors HTTP interceptor chain\n * @param client Terminating HTTP handler\n */\nexport function callHttpInterceptors<T>(\n  interceptors: HttpInterceptorInterface<T>[],\n  client: HttpCallExecutor<T>\n): HttpCallExecutor<T> {\n  let next = client;\n  for (let index = interceptors.length - 1; index >= 0; index--) {\n    const current = interceptors[index];\n    const last = next;\n    next = (request, options) => current(request, options, last);\n  }\n  return next;\n}\n\n/** Pass-through HTTP interceptor. */\nexport function passThroughInterceptor<T>(\n  request: HttpRequest,\n  requestOptions: T,\n  next: HttpCallExecutor<T>\n): Promise<HttpContext> {\n  return next(request, requestOptions);\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { Configuration, Environment } from './configuration';\n\n/** Default values for the configuration parameters of the client. */\nexport const DEFAULT_CONFIGURATION: Configuration = {\n  timeout: 0,\n  environment: Environment.Production,\n  baseUrl: 'https://www.example.com',\n  basicAuthUserName: 'TODO access token',\n  basicAuthPassword: 'TODO access token',\n};\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport JSONBig from 'json-bigint';\nimport { HttpContext } from '../http/httpContext';\nimport { HttpRequest } from '../http/httpRequest';\nimport { ApiResponse } from '../apiResponse';\n\n/**\n * Thrown when the HTTP status code is not okay.\n *\n * The ApiError extends the ApiResponse interface, so all ApiResponse\n * properties are available.\n */\nexport class ApiError<T = {}> extends Error\n  implements ApiResponse<T | undefined> {\n  public request: HttpRequest;\n  public statusCode: number;\n  public headers: Record<string, string>;\n  public result: T | undefined;\n  public body: string | Blob | NodeJS.ReadableStream;\n\n  constructor(context: HttpContext, message: string) {\n    super(message);\n\n    const { request, response } = context;\n    this.request = request;\n    this.statusCode = response.statusCode;\n    this.headers = response.headers;\n    this.body = response.body;\n\n    if (typeof response.body === 'string' && response.body !== '') {\n      const JSON = JSONBig({ useNativeBigInt: true });\n      try {\n        this.result = JSON.parse(response.body);\n      } catch (error) {\n        if (__DEV__) {\n          if (console) {\n            console.warn(\n              `Unexpected error: Could not parse HTTP response body as JSON. ${error.message}`\n            );\n          }\n        }\n      }\n    }\n  }\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport warning from 'tiny-warning';\n\n/**\n * Validates the protocol and removes duplicate forward slashes\n *\n * @param url URL to clean\n * @returns Sanitized URL\n */\nexport function sanitizeUrl(url: string): string {\n  // ensure that the urls are absolute\n  const protocolRegex = /^https?:\\/\\/[^/]+/;\n  const match = url.match(protocolRegex);\n  if (match === null) {\n    throw new Error(`Invalid URL format: ${url}`);\n  }\n\n  // remove redundant double-forward slashes\n  const protocol = match[0];\n  const queryUrl = url.substring(protocol.length).replace(/\\/\\/+/g, '/');\n  return protocol + queryUrl;\n}\n\n/**\n * Check whether value is an instance of Blob\n *\n * @remark\n * Reference: https://github.com/sindresorhus/is-blob/blob/master/index.js\n *\n * @param value Value to check\n * @returns True if the value is a Blob instance\n */\nexport function isBlob(value: unknown): value is Blob {\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n\n  return (\n    value instanceof Blob ||\n    Object.prototype.toString.call(value) === '[object Blob]'\n  );\n}\n\n// This is used by deprecated() to keep track of \"hits\".\nconst deprecatedHits: Record<string, boolean> = {};\n\n/**\n * Create warning for deprecated method usage.\n *\n * This is called once per deprecated method. If this method is called again\n * with the same arguments, no warning is generated.\n *\n * @param methodName Method name for deprecated method\n * @param notice Optional message for deprecation\n */\nexport function deprecated(methodName: string, notice?: string): void {\n  let message = `Method ${methodName} is deprecated.`;\n  if (notice) {\n    message += ` ${notice}`;\n  }\n  if (deprecatedHits[message]) {\n    return;\n  }\n  deprecatedHits[message] = true;\n  warning(false, message);\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\n/**\n * Thrown when the API call is aborted by the caller.\n *\n * Note that when an AbortError is thrown, it is not a guarantee that the API call\n * did not go through.\n */\nexport class AbortError extends Error {}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\n/**\n * Wraps file with mime-type and filename to be sent as part of an HTTP request.\n */\nexport class FileWrapper {\n  constructor(\n    public file: Blob | import('stream').Readable,\n    public options?: FileWrapperOptions\n  ) {\n    this.file = file;\n  }\n}\n\n/** File upload options such as filename and mime-type */\ninterface FileWrapperOptions {\n  /** Mime-type to be sent with the file */\n  contentType?: string;\n  /** Name of the file to be used in the upload data */\n  filename?: string;\n  /** Headers to be used in the multipart request */\n  headers?: Record<string, string>;\n}\n\n/** Returns true if value is a FileWrapper */\nexport function isFileWrapper(value: unknown): value is FileWrapper {\n  return value instanceof FileWrapper;\n}\n\n/**\n * Returns a deep clone of the FileWrapper instance\n *\n * @param fileWrapper FileWrapper instance to copy\n */\nexport function cloneFileWrapper(fileWrapper: FileWrapper): FileWrapper {\n  let options: FileWrapperOptions | undefined;\n  if (fileWrapper.options) {\n    options = cloneFileWrapperOptions(fileWrapper.options);\n  }\n  return new FileWrapper(fileWrapper.file, options);\n}\n\nfunction cloneFileWrapperOptions(\n  fileWrapperOptions: FileWrapperOptions\n): FileWrapperOptions {\n  const clone = { ...fileWrapperOptions };\n  if (fileWrapperOptions.headers) {\n    clone.headers = { ...fileWrapperOptions.headers };\n  }\n  return clone;\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\n/**\n * Set a header in the headers map.\n *\n * This method performs case-insensitive handling of header names.\n *\n * @param headers Map of headers\n * @param name Header name\n * @param value Header value\n */\n export function setHeader(\n  headers: Record<string, string | number | boolean>,\n  name: string,\n  value?: string | number | boolean | undefined\n): void {\n  const realHeaderName = lookupCaseInsensitive(headers, name);\n  setHeaderInternal(headers, realHeaderName, name, value);\n}\n\nfunction setHeaderInternal(\n  headers: Record<string, string | number | boolean | undefined>,\n  realHeaderName: string | null,\n  name: string,\n  value: string | number | boolean | undefined\n): void {\n  if (realHeaderName) {\n    delete headers[realHeaderName];\n  }\n  if (value) {\n    headers[name] = value;\n  }\n}\n\n/**\n * Set a header in the headers map if it is not already set.\n *\n * This method performs case-insensitive handling of header names.\n *\n * @param headers Map of headers\n * @param name Header name\n * @param value Header value\n */\nexport function setHeaderIfNotSet(\n  headers: Record<string, string | number | boolean>,\n  name: string,\n  value?: string | number | boolean | undefined\n): void {\n  const realHeaderName = lookupCaseInsensitive(headers, name);\n  if (!realHeaderName) {\n    setHeaderInternal(headers, realHeaderName, name, value);\n  }\n}\n\n/**\n * Get header from a map of headers.\n *\n * This method performs case-insensitive handling of header names.\n *\n * @param headers Map of headers\n * @param name Header name\n */\nexport function getHeader(\n  headers: Record<string, string>,\n  name: string\n): string | null {\n  const prop = lookupCaseInsensitive(headers, name);\n  if (prop) {\n    return headers[prop];\n  }\n  return null;\n}\n\n/**\n * Looks up and returns the matching property name from the object.\n *\n * This method returns the matching property name in the object which might or might\n * not have the same case as the prop argument.\n *\n * @param obj Object with string property names\n * @param prop Property to lookup\n */\nexport function lookupCaseInsensitive(\n  obj: Record<string, unknown>,\n  prop: string\n): string | null {\n  prop = prop.toLowerCase();\n  for (const p in obj) {\n    if (\n      Object.prototype.hasOwnProperty.call(obj, p) &&\n      prop === p.toLowerCase()\n    ) {\n      return p;\n    }\n  }\n  return null;\n}\n\n/**\n * Merge headers\n *\n * Header names are compared using case-insensitive comparison. This method\n * preserves the original header name. If the headersToMerge overrides an existing\n * header, then the new header name (with its casing) is used.\n *\n * @param headers Headers to merge into\n * @param headersToMerge Headers to set\n */\nexport function mergeHeaders(\n  headers: Record<string, string | number | boolean>,\n  headersToMerge: Record<string, string | number | boolean>\n): void {\n  const headerKeys: Record<string, string> = {};\n\n  // Create a map of lower-cased-header-name to original-header-names\n  for (const headerName of Object.getOwnPropertyNames(headers)) {\n    headerKeys[headerName.toLowerCase()] = headerName;\n  }\n\n  // Override headers with new values\n  for (const headerName of Object.getOwnPropertyNames(headersToMerge)) {\n    const lowerCasedName = headerName.toLowerCase();\n    if (headerKeys[lowerCasedName]) {\n      delete headers[headerKeys[lowerCasedName]];\n    }\n    headerKeys[lowerCasedName] = headerName;\n    headers[headerName] = headersToMerge[headerName];\n  }\n}\n\n/**\n * Assert headers object is valid\n */\nexport function assertHeaders(\n  headers: unknown\n): asserts headers is Record<string, string> {\n  if (headers === null || typeof headers !== 'object') {\n    throw new TypeError('Headers must be an object.');\n  }\n\n  for (const headerName of Object.getOwnPropertyNames(headers)) {\n    if (!isValidHeaderName(headerName)) {\n      throw new Error(`\"${headerName}\" is not a valid header name.`);\n    }\n    const headerValue = (headers as Record<string, unknown>)[headerName];\n    if (typeof headerValue !== 'string') {\n      throw new TypeError(\n        `Header value must be string but ${typeof headerValue} provided.`\n      );\n    }\n  }\n}\n\n/**\n * Return true if header name is valid\n * @param headerName Header name\n */\nexport function isValidHeaderName(headerName: string): boolean {\n  return /^[\\w!#$%&'*+.^`|~-]+$/.test(headerName);\n}\n\nexport const CONTENT_TYPE_HEADER = 'content-type';\nexport const ACCEPT_HEADER = 'accept';\nexport const CONTENT_LENGTH_HEADER = 'content-length';\nexport const AUTHORIZATION_HEADER = 'authorization';\nexport const FORM_URLENCODED_CONTENT_TYPE = 'application/x-www-form-urlencoded';\nexport const JSON_CONTENT_TYPE = 'application/json';\nexport const TEXT_CONTENT_TYPE = 'text/plain; charset=utf-8';\nexport const XML_CONTENT_TYPE = 'application/xml';\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { FileWrapper, isFileWrapper, cloneFileWrapper } from '../fileWrapper';\n\n/**\n * Type for Key-value pair for form-urlencoded serialization\n */\nexport type FormKeyValuePair = { key: string; value: string | FileWrapper };\n\n/**\n * Type for list of key-value pairs for form-urlencoded serialization\n */\nexport type FormKeyValuePairList = FormKeyValuePair[];\n\n/**\n * Type for formatting function used to create key for nested arrays\n */\nexport type ArrayPrefixFunction = (\n  prefix: string,\n  key: number | string\n) => string;\n\n/**\n * Array prefix format: item[1]=1&item[2]=2\n */\nexport const indexedPrefix: ArrayPrefixFunction = (prefix, key) =>\n  `${prefix}[${key}]`;\n\n/**\n * Array prefix format: item[]=1&item[]=2\n */\nexport const unindexedPrefix: ArrayPrefixFunction = prefix => prefix + '[]';\n\n/**\n * Array prefix format: item=1&item=2\n */\nexport const plainPrefix: ArrayPrefixFunction = prefix => prefix;\n\n/**\n * Converts an object to a list of key-value pairs for form-urlencoded serialization.\n *\n * @param obj The object to serialize\n * @param prefixFormat Formatting function to create key for nested arrays\n * @return Result of serialization\n */\nexport function formDataEncodeObject(\n  obj: Record<string, unknown>,\n  prefixFormat: ArrayPrefixFunction = indexedPrefix\n): FormKeyValuePairList {\n  const result: FormKeyValuePairList = [];\n\n  for (const key of Object.keys(obj)) {\n    const value = obj[key];\n    if (value === null || value === undefined) {\n      continue;\n    } else if (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'boolean' ||\n      typeof value === 'bigint'\n    ) {\n      result.push({ key, value: value.toString() });\n    } else if (isFileWrapper(value)) {\n      result.push({ key, value: cloneFileWrapper(value) });\n    } else if (Array.isArray(value)) {\n      for (let iter = 0; iter < value.length; iter += 1) {\n        result.push(\n          ...formDataEncodeObject({ [prefixFormat(key, iter)]: value[iter] })\n        );\n      }\n    } else if (typeof value === 'object') {\n      for (const objectKey in value) {\n        if (Object.prototype.hasOwnProperty.call(value, objectKey)) {\n          const element = value[objectKey as keyof typeof value];\n          result.push(\n            ...formDataEncodeObject({\n              [indexedPrefix(key, objectKey)]: element,\n            })\n          );\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Return a new list with all key-value pairs, which have a FileWrapper as value, removed\n *\n * @param params List of key-value pairs\n */\nexport function filterFileWrapperFromKeyValuePairs(\n  params: FormKeyValuePairList\n): { key: string; value: string }[] {\n  return params.filter(p => !isFileWrapper(p.value)) as any;\n}\n\n/**\n * Serializes an object for a form-urlencoded request.\n *\n * Nested and complex types in values will be flattened using {@link formDataEncodeObject() function} method.\n *\n * @param  obj The object to be serialized\n * @return The result of serialization\n */\nexport function urlEncodeObject(obj: Record<string, unknown>): string {\n  const params = formDataEncodeObject(obj);\n  return urlEncodeKeyValuePairs(params);\n}\n\n/**\n * Serializes a list of key-value pairs for a form-urlencoded request.\n *\n * @param params List of key-value pairs to serialize\n * @return The result of serialization\n */\nexport function urlEncodeKeyValuePairs(\n  params: FormKeyValuePairList | undefined\n): string {\n  const encode = encodeURIComponent;\n  return (params || [])\n    .map(p => `${encode(p.key)}=${encode(p.value.toString())}`)\n    .join('&');\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\n import axios, { AxiosHeaders, AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\n import isNode from 'detect-node';\n import FormData from 'form-data';\n import { isBlob } from '../apiHelper';\n import { AbortError } from '../errors/abortError';\n import { isFileWrapper } from '../fileWrapper';\n import {\n   CONTENT_TYPE_HEADER,\n   FORM_URLENCODED_CONTENT_TYPE,\n   mergeHeaders,\n   setHeader,\n   setHeaderIfNotSet,\n } from './httpHeaders';\n import { HttpRequest } from './httpRequest';\n import { HttpResponse } from './httpResponse';\n import { urlEncodeKeyValuePairs } from './queryString';\n \n export const DEFAULT_AXIOS_CONFIG_OVERRIDES: AxiosRequestConfig = {\n   transformResponse: [],\n };\n \n export const DEFAULT_TIMEOUT = 30 * 1000;\n \n /**\n  * HTTP client implementation.\n  *\n  * This implementation is a wrapper over the Axios client.\n  */\n export class HttpClient {\n   private _axiosInstance: AxiosInstance;\n   private _timeout: number;\n \n   constructor({\n     clientConfigOverrides,\n     timeout = DEFAULT_TIMEOUT,\n   }: { clientConfigOverrides?: AxiosRequestConfig; timeout?: number } = {}) {\n     this._timeout = timeout;\n     this._axiosInstance = axios.create({\n       ...DEFAULT_AXIOS_CONFIG_OVERRIDES,\n       ...clientConfigOverrides,\n     });\n   }\n \n   /** Converts an HttpRequest object to an Axios request. */\n   public convertHttpRequest(req: HttpRequest): AxiosRequestConfig {\n     const newRequest: AxiosRequestConfig = {\n       method: req.method,\n       url: req.url,\n       responseType: 'text',\n       headers: { ...req.headers },\n     };\n \n     if (req.auth) {\n       // Set basic auth credentials if provided\n       newRequest.auth = {\n         username: req.auth.username,\n         password: req.auth.password || '',\n       };\n     }\n     \n     const requestBody = req.body;\n     if (requestBody?.type === 'text') {\n       newRequest.data = requestBody.content;\n     } else if (\n       requestBody?.type === 'form-data' &&\n       requestBody.content.some(item => isFileWrapper(item.value))\n     ) {\n       // Create multipart request if a file is present\n       const form = new FormData();\n       for (const iter of requestBody.content) {\n         if (isFileWrapper(iter.value)) {\n           let fileData = iter.value.file;\n \n           // Make sure Blob has the correct content type if provided\n           if (isBlob(fileData) && iter.value.options?.contentType) {\n             fileData = new Blob([fileData], {\n               type: iter.value.options.contentType,\n             });\n           }\n \n           form.append(iter.key, fileData, iter.value.options);\n         } else {\n           form.append(iter.key, iter.value);\n         }\n       }\n \n       newRequest.data = form;\n       mergeHeaders(newRequest.headers as AxiosHeaders || {} , form.getHeaders());\n     } else if (\n       requestBody?.type === 'form-data' ||\n       requestBody?.type === 'form'\n     ) {\n       // Create form-urlencoded request\n       setHeader(\n         newRequest.headers as AxiosHeaders || {},\n         CONTENT_TYPE_HEADER,\n         FORM_URLENCODED_CONTENT_TYPE\n       );\n       newRequest.data = urlEncodeKeyValuePairs(requestBody.content);\n     } else if (requestBody?.type === 'stream') {\n       let contentType = 'application/octet-stream';\n       if (isBlob(requestBody.content.file) && requestBody.content.file.type) {\n         // Set Blob mime type as the content-type header if present\n         contentType = requestBody.content.file.type;\n       } else if (requestBody.content.options?.contentType) {\n         // Otherwise, use the content type if available.\n         contentType = requestBody.content.options.contentType;\n       }\n       setHeaderIfNotSet(newRequest.headers as AxiosHeaders || {}, CONTENT_TYPE_HEADER, contentType);\n       newRequest.data = requestBody.content.file;\n     } \n     else if (requestBody && typeof(requestBody['type']) !== 'undefined') {\n \n       throw new Error(\n         `HTTP client encountered unknown body type '${requestBody[\"type\"]}'. Could not execute HTTP request.`\n       );\n     }\n \n     if (req.responseType === 'stream') {\n       newRequest.responseType = isNode ? 'stream' : 'blob';\n     }\n \n     // Prevent superagent from converting any status code to error\n     newRequest.validateStatus = () => true;\n \n     // Set 30 seconds timeout\n     newRequest.timeout = this._timeout;\n \n     return newRequest;\n   }\n \n   /** Converts an Axios response to an HttpResponse object. */\n   public convertHttpResponse(resp: AxiosResponse): HttpResponse {\n     return {\n       body: resp.data,\n       headers: resp.headers as AxiosHeaders,\n       statusCode: resp.status,\n     };\n   }\n \n   /**\n    * Executes the HttpRequest with the given options and returns the HttpResponse\n    * or throws an error.\n    */\n   public async executeRequest(\n     request: HttpRequest,\n     requestOptions?: { abortSignal?: AbortSignal }\n   ): Promise<HttpResponse> {\n     const axiosRequest = this.convertHttpRequest(request);\n \n     if (requestOptions?.abortSignal) {\n       // throw if already aborted; do not place HTTP call\n       if (requestOptions.abortSignal.aborted) {\n         throw this.abortError();\n       }\n \n       const cancelToken = axios.CancelToken.source();\n       axiosRequest.cancelToken = cancelToken.token;\n \n       // attach abort event handler\n       requestOptions.abortSignal.addEventListener('abort', () => {\n         cancelToken.cancel();\n       });\n     }\n \n     try {\n       return this.convertHttpResponse(await this._axiosInstance(axiosRequest));\n     } catch (error) {\n       // abort error should be thrown as the AbortError\n       if (axios.isCancel(error)) {\n         throw this.abortError();\n       }\n \n       throw error;\n     }\n   }\n \n   private abortError() {\n     return new AbortError('The HTTP call was aborted.');\n   }\n }\n \n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport flatMap from 'lodash.flatmap';\n\n/** Marker for skipping URL-encoding when used with Path templating */\nexport class SkipEncode<T extends PathTemplatePrimitiveTypes> {\n  constructor(public value: T) {}\n}\n\nexport type PathTemplatePrimitiveTypes = string | string[] | number | number[];\n\n/** Path template argument type */\nexport type PathTemplateTypes =\n  | PathTemplatePrimitiveTypes\n  | SkipEncode<PathTemplatePrimitiveTypes>;\n\n/**\n * URL path templating method.\n *\n * Template arguments of array type are imploded using the path separator and\n * individual elements are URL-encoded.\n *\n * Template arguments are URL-encoded unless wrapped in a SkipEncode instance.\n */\nexport function pathTemplate(\n  strings: TemplateStringsArray,\n  ...args: PathTemplateTypes[]\n) {\n  const values = flatMap(\n    interweaveArrays(\n      strings.map(s => new SkipEncode(s)),\n      args\n    ),\n    encodePathTemplateSegment\n  );\n  const pathSegment = values.join('');\n  return pathSegment;\n}\n\nfunction encodePathTemplateSegment(value: PathTemplateTypes) {\n  let skipEncode = false;\n  const encode = (m: string | number) =>\n    skipEncode ? m.toString() : encodeURIComponent(m);\n  if (value instanceof SkipEncode) {\n    value = value.value;\n    skipEncode = true;\n  }\n  return Array.isArray(value)\n    ? (value as Array<string | number>).map<string | number>(encode).join('/')\n    : [encode(value)];\n}\n\nfunction interweaveArrays<A, B>(\n  a: ReadonlyArray<A>,\n  b: ReadonlyArray<B>\n): Array<A | B> {\n  const min = Math.min(a.length, b.length);\n  return Array.apply(null, new Array(min))\n    .reduce((result: Array<A | B>, _, index) => {\n      result.push(a[index], b[index]);\n      return result;\n    }, [])\n    .concat((a.length > min ? a : b).slice(min));\n}\n","import { SchemaValidationError } from '../schema';\n\n/**\n * Thrown when one or more arguments passed to a method fail validation.\n */\nexport class ArgumentsValidationError extends Error {\n  public readonly errors: Record<string, SchemaValidationError[]>;\n  constructor(errors: Record<string, SchemaValidationError[]>) {\n    const errorKeys = Object.keys(errors);\n\n    let message: string;\n    if (errorKeys.length === 0) {\n      message = 'One or more arguments failed validation.';\n    } else if (errorKeys.length === 1 && errors[errorKeys[0]].length === 1) {\n      message = `Argument for '${errorKeys[0]}' failed validation.\\n\\n${\n        errors[errorKeys[0]][0].message\n      }`;\n    } else {\n      message = `The following arguments failed validation: ${errorKeys.join(\n        ', '\n      )}.\\n\\n`;\n\n      const msgList: string[] = [];\n      for (const param of errorKeys) {\n        msgList.push(`> For argument '${param}':`);\n        if (errors[param].length === 1) {\n          msgList.push(errors[param][0].message!);\n        } else {\n          for (let index = 0; index < errors[param].length; index++) {\n            const error = errors[param][index];\n            msgList.push(`>> Issue #${index + 1}\\n\\n${error.message}`);\n          }\n        }\n      }\n\n      message += msgList.join('\\n\\n');\n    }\n\n    super(message);\n    this.errors = errors;\n  }\n}\n","import { HttpRequest } from '../http/httpRequest';\nimport { ApiResponse } from '../apiResponse';\nimport { SchemaValidationError } from '../schema';\n\n/**\n * Thrown when the API response does not match the schema.\n */\nexport class ResponseValidationError extends Error\n  implements ApiResponse<never> {\n  public request: HttpRequest;\n  public statusCode: number;\n  public headers: Record<string, string>;\n  public result: never;\n  public body: string | Blob | NodeJS.ReadableStream;\n  public errors: SchemaValidationError[];\n\n  constructor(apiResponse: ApiResponse<any>, errors: SchemaValidationError[]) {\n    let message = 'The response did not match the response schema.';\n\n    if (errors.length === 1) {\n      message += `\\n\\n${errors[0].message}`;\n    } else {\n      message += errors\n        .map((e, i) => `\\n\\n> Issue #${i + 1}\\n\\n${e.message}`)\n        .join('');\n    }\n\n    super(message);\n\n    this.request = apiResponse.request;\n    this.statusCode = apiResponse.statusCode;\n    this.headers = apiResponse.headers;\n    this.body = apiResponse.body;\n    this.errors = errors;\n  }\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport {\n  Schema,\n  SchemaMappedType,\n  SchemaType,\n  SchemaValidationError,\n  validateAndUnmap,\n} from '../schema';\nimport { ArgumentsValidationError } from '../errors/argumentsValidationError';\n\n/**\n * Prepares arguments for being sent in the API request.\n *\n * Each argument is validated and converted to a JSON-serialization ready value.\n *\n * If one or more arguments fail validation, an ArgumentsValidationError is\n * thrown, which contains the validation details for all arguments that failed\n * validation.\n *\n * @param params Map of arguments with values and schema\n * @returns Map of serialization-ready argument values\n *\n * @throws ArgumentsValidationError\n */\nexport function prepareArgs<\n  S extends Schema<any, any>,\n  T extends Record<string, [SchemaType<S>, S]>\n>(params: T): { [key in keyof T]: SchemaMappedType<T[key][1]> } {\n  const validationErrors: Record<string, SchemaValidationError[]> = {};\n  const result: Partial<{ [key in keyof T]: SchemaMappedType<T[key][1]> }> = {};\n\n  for (const paramName in params) {\n    if (Object.prototype.hasOwnProperty.call(params, paramName)) {\n      const paramInfo = params[paramName];\n      const validationResult = validateAndUnmap(paramInfo[0], paramInfo[1]);\n      if (validationResult.errors) {\n        validationErrors[paramName] = validationResult.errors;\n      } else {\n        result[paramName] = validationResult.result;\n      }\n    }\n  }\n\n  if (Object.keys(validationErrors).length > 0) {\n    throw new ArgumentsValidationError(validationErrors);\n  }\n\n  return result as any;\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport isNode from 'detect-node';\nimport JSONBig from 'json-bigint';\nimport { FileWrapper } from '../fileWrapper';\nimport { deprecated, sanitizeUrl } from '../apiHelper';\nimport { ApiResponse } from '../apiResponse';\nimport { ArgumentsValidationError } from '../errors/argumentsValidationError';\nimport { ResponseValidationError } from '../errors/responseValidationError';\nimport {\n  Schema,\n  validateAndMap,\n  validateAndMapXml,\n  validateAndUnmapXml,\n} from '../schema';\nimport { HttpContext } from './httpContext';\nimport {\n  ACCEPT_HEADER,\n  CONTENT_LENGTH_HEADER,\n  CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE,\n  mergeHeaders,\n  setHeader,\n  setHeaderIfNotSet,\n  TEXT_CONTENT_TYPE,\n  XML_CONTENT_TYPE,\n} from './httpHeaders';\nimport {\n  callHttpInterceptors,\n  HttpInterceptorInterface,\n} from './httpInterceptor';\nimport {\n  HttpMethod,\n  HttpRequest,\n  HttpRequestMultipartFormBody,\n  HttpRequestUrlEncodedFormBody,\n} from './httpRequest';\nimport { HttpResponse } from './httpResponse';\nimport {\n  pathTemplate,\n  PathTemplatePrimitiveTypes,\n  PathTemplateTypes,\n  SkipEncode,\n} from './pathTemplate';\nimport {\n  filterFileWrapperFromKeyValuePairs,\n  formDataEncodeObject,\n  urlEncodeObject,\n} from './queryString';\nimport { prepareArgs } from './validate';\nimport { xmlDeserialize, xmlSerialize } from './xmlSerialization';\n\nexport interface RequestBuilderFactory<BaseUrlParamType, AuthParams> {\n  (httpMethod: HttpMethod, path?: string): RequestBuilder<\n    BaseUrlParamType,\n    AuthParams\n  >;\n}\n\nconst JSON = JSONBig({ useNativeBigInt: true });\n\ntype QueryValue =\n  | string\n  | string[]\n  | number\n  | number[]\n  | bigint\n  | bigint[]\n  | boolean\n  | null\n  | undefined;\n\nexport function skipEncode<T extends PathTemplatePrimitiveTypes>(\n  value: T\n): SkipEncode<T> {\n  return new SkipEncode(value);\n}\n\n/** Optional API call options such as the Abort Signal. */\nexport interface RequestOptions {\n  /**\n   * Allows cancelling the API call using an Abort Signal.\n   *\n   * This must be set to an instance compatible with the\n   * [WHATWG AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal). The\n   * AbortSignal comes built-in in modern browsers and can be polyfilled for older browser versions\n   * and Node.js using the\n   * [abort-controller](https://github.com/mysticatea/abort-controller) package.\n   */\n  abortSignal?: AbortSignal;\n}\n\nexport interface HttpClientInterface {\n  (request: HttpRequest, requestOptions?: RequestOptions): Promise<\n    HttpResponse\n  >;\n}\n\nexport interface ApiErrorConstructor {\n  new (response: HttpContext, message: string): any;\n}\n\nexport interface AuthenticatorInterface<AuthParams> {\n  (authParams?: AuthParams): HttpInterceptorInterface<\n    RequestOptions | undefined\n  >;\n}\n\nexport interface RequestBuilder<BaseUrlParamType, AuthParams> {\n  deprecated(methodName: string, message?: string): void;\n  prepareArgs: typeof prepareArgs;\n  method(httpMethodName: HttpMethod): void;\n  baseUrl(arg: BaseUrlParamType): void;\n  authenticate(params: AuthParams): void;\n  appendPath(path: string): void;\n  appendTemplatePath(\n    strings: TemplateStringsArray,\n    ...args: Array<PathTemplateTypes>\n  ): void;\n  acceptJson(): void;\n  accept(acceptHeaderValue: string): void;\n  contentType(contentTypeHeaderValue: string): void;\n  header(name: string, value?: string | boolean | number): void;\n  headers(headersToMerge: Record<string, string>): void;\n  query(name: string, value: QueryValue): void;\n  query(parameters?: Record<string, QueryValue> | null): void;\n  form(parameters: Record<string, unknown>): void;\n  formData(parameters: Record<string, unknown>): void;\n  text(body: string): void;\n  json(data: unknown): void;\n  xml<T>(\n    argName: string,\n    data: T,\n    rootName: string,\n    schema: Schema<T, any>\n  ): void;\n  stream(file?: FileWrapper): void;\n  toRequest(): HttpRequest;\n  intercept(\n    interceptor: HttpInterceptorInterface<RequestOptions | undefined>\n  ): void;\n  interceptRequest(interceptor: (request: HttpRequest) => HttpRequest): void;\n  interceptResponse(interceptor: (response: HttpContext) => HttpContext): void;\n  defaultToError(apiErrorCtor: ApiErrorConstructor): void;\n  validateResponse(validate: boolean): void;\n  throwOn<ErrorCtorArgs extends any[]>(\n    statusCode: number | [number, number],\n    errorConstructor: {\n      new (response: HttpContext, ...args: ErrorCtorArgs): any;\n    },\n    ...args: ErrorCtorArgs\n  ): void;\n  call(requestOptions?: RequestOptions): Promise<ApiResponse<void>>;\n  callAsJson<T>(\n    schema: Schema<T, any>,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<T>>;\n  callAsStream(\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>>;\n  callAsText(requestOptions?: RequestOptions): Promise<ApiResponse<string>>;\n  callAsOptionalText(\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<string | undefined>>;\n  callAsXml<T>(\n    rootName: string,\n    schema: Schema<T, any>,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<T>>;\n  callAsXml<T>(\n    rootName: string,\n    schema: Schema<T, any>,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<T>>;\n}\n\nexport class DefaultRequestBuilder<BaseUrlParamType, AuthParams>\n  implements RequestBuilder<BaseUrlParamType, AuthParams> {\n  protected _accept?: string;\n  protected _contentType?: string;\n  protected _headers: Record<string, string>;\n  protected _body?: string;\n  protected _stream?: FileWrapper;\n  protected _query: string[];\n  protected _form?: HttpRequestUrlEncodedFormBody['content'];\n  protected _formData?: HttpRequestMultipartFormBody['content'];\n  protected _baseUrlArg: BaseUrlParamType | undefined;\n  protected _validateResponse: boolean;\n  protected _interceptors: HttpInterceptorInterface<\n    RequestOptions | undefined\n  >[];\n  protected _authParams?: AuthParams;\n  public prepareArgs: typeof prepareArgs;\n\n  constructor(\n    protected _httpClient: HttpClientInterface,\n    protected _baseUrlProvider: (arg?: BaseUrlParamType) => string,\n    protected _apiErrorFactory: ApiErrorConstructor,\n    protected _authenticationProvider: AuthenticatorInterface<AuthParams>,\n    protected _httpMethod: HttpMethod,\n    protected _path?: string\n  ) {\n    this._headers = {};\n    this._query = [];\n    this._interceptors = [];\n    this._validateResponse = true;\n    this._addResponseValidator();\n    this._addAuthentication();\n    this.prepareArgs = prepareArgs.bind(this);\n  }\n  authenticate(params: AuthParams): void {\n    this._authParams = params;\n  }\n  deprecated(methodName: string, message?: string): void {\n    deprecated(methodName, message);\n  }\n  appendTemplatePath(\n    strings: TemplateStringsArray,\n    ...args: Array<PathTemplateTypes>\n  ): void {\n    const pathSegment = pathTemplate(strings, ...args);\n    this.appendPath(pathSegment);\n  }\n  method(httpMethodName: HttpMethod): void {\n    this._httpMethod = httpMethodName;\n  }\n  baseUrl(arg: BaseUrlParamType): void {\n    this._baseUrlArg = arg;\n  }\n  appendPath(path: string): void {\n    this._path = this._path ? mergePath(this._path, path) : path;\n  }\n  acceptJson(): void {\n    this._accept = JSON_CONTENT_TYPE;\n  }\n  accept(acceptHeaderValue: string): void {\n    this._accept = acceptHeaderValue;\n  }\n  contentType(contentTypeHeaderValue: string): void {\n    this._contentType = contentTypeHeaderValue;\n  }\n  header(name: string, value?: string | boolean | number): void {\n    if (value === undefined) {\n      return;\n    }\n    setHeader(this._headers, name, value.toString());\n  }\n  headers(headersToMerge: Record<string, string>): void {\n    mergeHeaders(this._headers, headersToMerge);\n  }\n  query(name: string, value: QueryValue): void;\n  query(parameters?: Record<string, QueryValue> | null): void;\n  query(\n    nameOrParameters: string | Record<string, QueryValue> | null | undefined,\n    value?: unknown\n  ): void {\n    if (nameOrParameters === null || nameOrParameters === undefined) return;\n    const queryString =\n      typeof nameOrParameters === 'string'\n        ? urlEncodeObject({\n            [nameOrParameters]: value,\n          })\n        : urlEncodeObject(nameOrParameters);\n    if (queryString) {\n      this._query.push(queryString);\n    }\n  }\n  text(body: string): void {\n    this._body = body;\n    this._setContentTypeIfNotSet(TEXT_CONTENT_TYPE);\n  }\n  json(data: unknown): void {\n    this._body = JSON.stringify(data);\n    this._setContentTypeIfNotSet(JSON_CONTENT_TYPE);\n  }\n  xml<T>(\n    argName: string,\n    data: T,\n    rootName: string,\n    schema: Schema<T, any>\n  ): void {\n    const mappingResult = validateAndUnmapXml(data, schema);\n    if (mappingResult.errors) {\n      throw new ArgumentsValidationError({ [argName]: mappingResult.errors });\n    }\n    this._body = xmlSerialize(rootName, mappingResult.result);\n    this._setContentTypeIfNotSet(XML_CONTENT_TYPE);\n  }\n  stream(file?: FileWrapper): void {\n    this._stream = file;\n  }\n  form(parameters: Record<string, unknown>): void {\n    this._form = filterFileWrapperFromKeyValuePairs(\n      formDataEncodeObject(parameters)\n    );\n  }\n  formData(parameters: Record<string, unknown>): void {\n    this._formData = formDataEncodeObject(parameters);\n  }\n  toRequest(): HttpRequest {\n    const request: HttpRequest = {\n      method: this._httpMethod,\n      url: mergePath(this._baseUrlProvider(this._baseUrlArg), this._path),\n    };\n\n    if (this._query.length > 0) {\n      const queryString = this._query.join('&');\n      request.url +=\n        (request.url.indexOf('?') === -1 ? '?' : '&') + queryString;\n    }\n\n    request.url = sanitizeUrl(request.url);\n\n    // defensively copy headers\n    const headers = { ...this._headers };\n\n    if (this._accept) {\n      setHeader(headers, ACCEPT_HEADER, this._accept);\n    }\n\n    if (this._contentType) {\n      setHeader(headers, CONTENT_TYPE_HEADER, this._contentType);\n    }\n\n    setHeader(headers, CONTENT_LENGTH_HEADER);\n\n    request.headers = headers;\n\n    if (this._body !== undefined) {\n      request.body = { type: 'text', content: this._body };\n    } else if (this._form !== undefined) {\n      request.body = { type: 'form', content: this._form };\n    } else if (this._formData !== undefined) {\n      request.body = { type: 'form-data', content: this._formData };\n    } else if (this._stream !== undefined) {\n      request.body = { type: 'stream', content: this._stream };\n    }\n\n    return request;\n  }\n  intercept(\n    interceptor: HttpInterceptorInterface<RequestOptions | undefined>\n  ): void {\n    this._interceptors.push(interceptor);\n  }\n  interceptRequest(\n    interceptor: (httpRequest: HttpRequest) => HttpRequest\n  ): void {\n    this.intercept((req, opt, next) => next(interceptor(req), opt));\n  }\n  interceptResponse(interceptor: (response: HttpContext) => HttpContext): void {\n    this.intercept(async (req, opt, next) => interceptor(await next(req, opt)));\n  }\n  defaultToError(apiErrorCtor: ApiErrorConstructor): void {\n    this._apiErrorFactory = apiErrorCtor;\n  }\n  validateResponse(validate: boolean): void {\n    this._validateResponse = validate;\n  }\n  throwOn<ErrorCtorArgs extends any[]>(\n    statusCode: number | [number, number],\n    errorConstructor: {\n      new (response: HttpContext, ...args: ErrorCtorArgs): any;\n    },\n    ...args: ErrorCtorArgs\n  ): void {\n    this.interceptResponse(context => {\n      const { response } = context;\n      if (\n        (typeof statusCode === 'number' &&\n          response.statusCode === statusCode) ||\n        (typeof statusCode !== 'number' &&\n          response.statusCode >= statusCode[0] &&\n          response.statusCode <= statusCode[1])\n      ) {\n        throw new errorConstructor(context, ...args);\n      }\n      return context;\n    });\n  }\n  async call(requestOptions?: RequestOptions): Promise<ApiResponse<void>> {\n    // Prepare the HTTP pipeline\n    const pipeline = callHttpInterceptors(\n      this._interceptors,\n      async (request, opt) => {\n        const response = await this._httpClient(request, opt);\n        return { request, response };\n      }\n    );\n\n    // Execute HTTP pipeline\n    const { request, response } = await pipeline(\n      this.toRequest(),\n      requestOptions\n    );\n\n    return { ...response, request, result: undefined };\n  }\n  async callAsText(\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<string>> {\n    const result = await this.call(requestOptions);\n    if (typeof result.body !== 'string') {\n      throw new Error('Could not parse body as string.'); // TODO: Replace with SDK error\n    }\n    return { ...result, result: result.body };\n  }\n  async callAsOptionalText(\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<string | undefined>> {\n    const result = await this.call(requestOptions);\n    if (typeof result.body !== 'string') {\n      return { ...result, result: undefined };\n    }\n    return { ...result, result: result.body };\n  }\n  async callAsStream(\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>> {\n    this.interceptRequest(req => ({ ...req, responseType: 'stream' }));\n    const result = await this.call(requestOptions);\n    return { ...result, result: convertToStream(result.body) };\n  }\n  async callAsJson<T>(\n    schema: Schema<T>,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<T>> {\n    this.interceptRequest(request => {\n      const headers = { ...request.headers };\n      setHeaderIfNotSet(headers, ACCEPT_HEADER, JSON_CONTENT_TYPE);\n      return { ...request, headers };\n    });\n    const result = await this.call(requestOptions);\n    if (result.body === '') {\n      throw new Error(\n        'Could not parse body as JSON. The response body is empty.'\n      );\n    }\n    if (typeof result.body !== 'string') {\n      throw new Error(\n        'Could not parse body as JSON. The response body is not a string.'\n      );\n    }\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(result.body);\n    } catch (error) {\n      throw new Error(`Could not parse body as JSON.\\n\\n${error.message}`);\n    }\n    const mappingResult = validateAndMap(parsed, schema);\n    if (mappingResult.errors) {\n      throw new ResponseValidationError(result, mappingResult.errors);\n    }\n    return { ...result, result: mappingResult.result };\n  }\n  async callAsXml<T>(\n    rootName: string,\n    schema: Schema<T, any>,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<T>> {\n    this.interceptRequest(request => {\n      const headers = { ...request.headers };\n      setHeaderIfNotSet(headers, ACCEPT_HEADER, XML_CONTENT_TYPE);\n      return { ...request, headers };\n    });\n    const result = await this.call(requestOptions);\n    if (result.body === '') {\n      throw new Error(\n        'Could not parse body as XML. The response body is empty.'\n      );\n    }\n    if (typeof result.body !== 'string') {\n      throw new Error(\n        'Could not parse body as XML. The response body is not a string.'\n      );\n    }\n    let xmlObject: unknown;\n    try {\n      xmlObject = await xmlDeserialize(rootName, result.body);\n    } catch (error) {\n      throw new Error(`Could not parse body as XML.\\n\\n${error.message}`);\n    }\n    const mappingResult = validateAndMapXml(xmlObject, schema);\n    if (mappingResult.errors) {\n      throw new ResponseValidationError(result, mappingResult.errors);\n    }\n    return { ...result, result: mappingResult.result };\n  }\n  private _setContentTypeIfNotSet(contentType: string) {\n    if (!this._contentType) {\n      setHeaderIfNotSet(this._headers, CONTENT_TYPE_HEADER, contentType);\n    }\n  }\n  private _addResponseValidator(): void {\n    this.interceptResponse(context => {\n      const { response } = context;\n      if (\n        this._validateResponse &&\n        (response.statusCode < 200 || response.statusCode >= 300)\n      ) {\n        throw new this._apiErrorFactory(\n          context,\n          `Response status code was not ok: ${response.statusCode}.`\n        );\n      }\n      return context;\n    });\n  }\n  private _addAuthentication() {\n    this.intercept((...args) => {\n      const handler = this._authenticationProvider(this._authParams);\n      return handler(...args);\n    });\n  }\n}\n\nexport function createRequestBuilderFactory<BaseUrlParamType, AuthParams>(\n  httpClient: HttpClientInterface,\n  baseUrlProvider: (arg?: BaseUrlParamType) => string,\n  apiErrorFactory: ApiErrorConstructor,\n  authenticationProvider: AuthenticatorInterface<AuthParams>\n): RequestBuilderFactory<BaseUrlParamType, AuthParams> {\n  return (httpMethod, path?) => {\n    return new DefaultRequestBuilder(\n      httpClient,\n      baseUrlProvider,\n      apiErrorFactory,\n      authenticationProvider,\n      httpMethod,\n      path\n    );\n  };\n}\n\nfunction mergePath(left: string, right?: string): string {\n  if (!right || right === '') {\n    return left;\n  }\n\n  if (left[left.length - 1] === '/' && right[0] === '/') {\n    return left + right.substr(1);\n  } else if (left[left.length - 1] === '/' || right[0] === '/') {\n    return left + right;\n  } else {\n    return `${left}/${right}`;\n  }\n}\n\nexport function convertToStream(\n  content: string | Blob | NodeJS.ReadableStream\n): Blob | NodeJS.ReadableStream {\n  if (typeof content !== 'string') {\n    return content;\n  }\n\n  if (isNode) {\n    // ref: https://stackoverflow.com/a/22085851\n    const rs = new (require('stream').Readable)();\n    rs._read = () => {};\n    rs.push(content);\n    rs.push(null);\n    return rs;\n  }\n\n  return new Blob([content]);\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nexport function xmlSerialize(_rootName: string, _value: unknown): string {\n  throw new Error('XML serialization is not available.');\n}\n\nexport async function xmlDeserialize(\n  _rootName: string,\n  _xmlString: string\n): Promise<any> {\n  throw new Error('XML deserialization is not available.');\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { basicAuthAuthenticationProvider } from './authentication';\nimport {\n  AuthParams,\n  ClientInterface,\n  SdkRequestBuilder,\n  SdkRequestBuilderFactory,\n  Server,\n} from './clientInterface';\nimport { Configuration, Environment } from './configuration';\nimport { DEFAULT_CONFIGURATION } from './defaultConfiguration';\nimport { ApiError } from './errors/apiError';\nimport { HttpClient } from './http/httpClient';\nimport { pathTemplate, SkipEncode } from './http/pathTemplate';\nimport {\n  AuthenticatorInterface,\n  createRequestBuilderFactory,\n  HttpClientInterface,\n} from './http/requestBuilder';\n\nconst USER_AGENT = 'node-messaging';\n\nexport class Client implements ClientInterface {\n  private _config: Readonly<Configuration>;\n  private _requestBuilderFactory: SdkRequestBuilderFactory;\n\n  constructor(config?: Partial<Configuration>) {\n    this._config = {\n      ...DEFAULT_CONFIGURATION,\n      ...config,\n    };\n    this._requestBuilderFactory = createRequestHandlerFactory(\n      server => getBaseUri(server, this._config),\n      basicAuthAuthenticationProvider(this._config),\n      new HttpClient({\n        timeout: this._config.timeout,\n        clientConfigOverrides: this._config.unstable_httpClientOptions,\n      }),\n      [\n        withErrorHandlers,\n        withUserAgent,\n        withAuthenticationByDefault,\n      ]\n    );\n  }\n\n  public getRequestBuilderFactory(): SdkRequestBuilderFactory {\n    return this._requestBuilderFactory;\n  }\n\n  /**\n   * Clone this client and override given configuration options\n   */\n  public withConfiguration(config: Partial<Configuration>) {\n    return new Client({ ...this._config, ...config });\n  }\n}\n\nfunction createHttpClientAdapter(client: HttpClient): HttpClientInterface {\n  return async (request, requestOptions) => {\n    return await client.executeRequest(request, requestOptions);\n  };\n}\n\nfunction getBaseUri(server: Server = 'MessagingDefault', config: Configuration): string {\n  if (config.environment === Environment.Production) {\n    if (server === 'MessagingDefault') {\n      return 'https://messaging.bandwidth.com/api/v2';\n    }\n  }\n  if (config.environment === Environment.Custom) {\n    if (server === 'MessagingDefault') {\n      return pathTemplate`${new SkipEncode(config.baseUrl)}`;\n    }\n  }\n  throw new Error('Could not get Base URL. Invalid environment or server.');\n}\n\nfunction createRequestHandlerFactory(\n  baseUrlProvider: (server?: Server) => string,\n  authProvider: AuthenticatorInterface<AuthParams>,\n  httpClient: HttpClient,\n  addons: ((rb: SdkRequestBuilder) => void)[]\n): SdkRequestBuilderFactory {\n  const requestBuilderFactory = createRequestBuilderFactory(\n    createHttpClientAdapter(httpClient),\n    baseUrlProvider,\n    ApiError,\n    authProvider\n  );\n\n  return tap(requestBuilderFactory, ...addons);\n}\n\nfunction tap(\n  requestBuilderFactory: SdkRequestBuilderFactory,\n  ...callback: ((requestBuilder: SdkRequestBuilder) => void)[]\n): SdkRequestBuilderFactory {\n  return (...args) => {\n    const requestBuilder = requestBuilderFactory(...args);\n    callback.forEach(c => c(requestBuilder));\n    return requestBuilder;\n  };\n}\n\nfunction withErrorHandlers(rb: SdkRequestBuilder) {\n  rb.defaultToError(ApiError);\n}\n\nfunction withUserAgent(rb: SdkRequestBuilder) {\n  rb.header('user-agent', USER_AGENT);\n}\n\nfunction withAuthenticationByDefault(rb: SdkRequestBuilder) {\n  rb.authenticate(true);\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { passThroughInterceptor } from './http/httpInterceptor';\nimport { AuthenticatorInterface } from './http/requestBuilder';\n\n/** None authentication provider */\nexport const noneAuthenticationProvider = () => passThroughInterceptor;\n\nexport const basicAuthAuthenticationProvider = ({\n  basicAuthUserName,\n  basicAuthPassword,\n}: {\n  basicAuthUserName: string;\n  basicAuthPassword: string;\n}): AuthenticatorInterface<boolean> => {\n  return (requiresAuth?: boolean) => {\n    if (!requiresAuth) {\n      return passThroughInterceptor;\n    }\n\n    return (request, options, next) => {\n      request.auth = {\n        username: basicAuthUserName,\n        password: basicAuthPassword,\n      };\n\n      return next(request, options);\n    };\n  };\n};\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { ApiError } from './apiError';\n\n/**\n * Creates an instance of MessagingException\n */\n interface MessagingException {\n  type: string;\n  description: string;\n}\n\nexport class MessagingExceptionError extends ApiError<MessagingException> {}\n\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { array, number, object, optional, Schema, string } from '../schema';\n\nexport interface BandwidthMessage {\n  /** The id of the message */\n  id?: string;\n  /** The Bandwidth phone number associated with the message */\n  owner?: string;\n  /** The application ID associated with the message */\n  applicationId?: string;\n  /** The datetime stamp of the message in ISO 8601 */\n  time?: string;\n  /** The number of segments the original message from the user is broken into before sending over to carrier networks */\n  segmentCount?: number;\n  /** The direction of the message relative to Bandwidth. Can be in or out */\n  direction?: string;\n  /** The phone number recipients of the message */\n  to?: string[];\n  /** The phone number the message was sent from */\n  from?: string;\n  /** The list of media URLs sent in the message */\n  media?: string[];\n  /** The contents of the message */\n  text?: string;\n  /** The custom string set by the user */\n  tag?: string;\n  /** The priority specified by the user */\n  priority?: string;\n}\n\nexport const bandwidthMessageSchema: Schema<BandwidthMessage> = object({\n  id: ['id', optional(string())],\n  owner: ['owner', optional(string())],\n  applicationId: ['applicationId', optional(string())],\n  time: ['time', optional(string())],\n  segmentCount: ['segmentCount', optional(number())],\n  direction: ['direction', optional(string())],\n  to: ['to', optional(array(string()))],\n  from: ['from', optional(string())],\n  media: ['media', optional(array(string()))],\n  text: ['text', optional(string())],\n  tag: ['tag', optional(string())],\n  priority: ['priority', optional(string())],\n});\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { number, object, optional, Schema, string, nullable } from '../schema';\n\nexport interface BandwidthMessageItem {\n  /** The message id */\n  messageId?: string;\n  /** The account id of the message */\n  accountId?: string;\n  /** The source phone number of the message */\n  sourceTn?: string;\n  /** The recipient phone number of the message */\n  destinationTn?: string;\n  /** The status of the message */\n  messageStatus?: string;\n  /** The direction of the message relative to Bandwidth. INBOUND or OUTBOUND */\n  messageDirection?: string;\n  /** The type of message. sms or mms */\n  messageType?: string;\n  /** The number of segments the message was sent as */\n  segmentCount?: number;\n  /** The numeric error code of the message */\n  errorCode?: number;\n  /** The ISO 8601 datetime of the message */\n  receiveTime?: string;\n  /** The name of the carrier. Not currently supported for MMS, coming soon */\n  carrierName?: string | null;\n}\n\nexport const bandwidthMessageItemSchema: Schema<BandwidthMessageItem> = object({\n  messageId: ['messageId', optional(string())],\n  accountId: ['accountId', optional(string())],\n  sourceTn: ['sourceTn', optional(string())],\n  destinationTn: ['destinationTn', optional(string())],\n  messageStatus: ['messageStatus', optional(string())],\n  messageDirection: ['messageDirection', optional(string())],\n  messageType: ['messageType', optional(string())],\n  segmentCount: ['segmentCount', optional(number())],\n  errorCode: ['errorCode', optional(number())],\n  receiveTime: ['receiveTime', optional(string())],\n  carrierName: ['carrierName', nullable(optional(string()))],\n});\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { object, optional, Schema, string } from '../schema';\n\nexport interface PageInfo {\n  /** The link to the previous page for pagination */\n  prevPage?: string;\n  /** The link to the next page for pagination */\n  nextPage?: string;\n  /** The isolated pagination token for the previous page */\n  prevPageToken?: string;\n  /** The isolated pagination token for the next page */\n  nextPageToken?: string;\n}\n\nexport const pageInfoSchema: Schema<PageInfo> = object({\n  prevPage: ['prevPage', optional(string())],\n  nextPage: ['nextPage', optional(string())],\n  prevPageToken: ['prevPageToken', optional(string())],\n  nextPageToken: ['nextPageToken', optional(string())],\n});\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { array, lazy, number, object, optional, Schema } from '../schema';\nimport {\n  BandwidthMessageItem,\n  bandwidthMessageItemSchema,\n} from './bandwidthMessageItem';\nimport { PageInfo, pageInfoSchema } from './pageInfo';\n\nexport interface BandwidthMessagesList {\n  /** Total number of messages matched by the search */\n  totalCount?: number;\n  pageInfo?: PageInfo;\n  messages?: BandwidthMessageItem[];\n}\n\nexport const bandwidthMessagesListSchema: Schema<BandwidthMessagesList> = object(\n  {\n    totalCount: ['totalCount', optional(number())],\n    pageInfo: ['pageInfo', optional(lazy(() => pageInfoSchema))],\n    messages: [\n      'messages',\n      optional(array(lazy(() => bandwidthMessageItemSchema))),\n    ],\n  }\n);\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { number, object, optional, Schema, string } from '../schema';\n\nexport interface Media {\n  content?: string;\n  contentLength?: number;\n  mediaName?: string;\n}\n\nexport const mediaSchema: Schema<Media> = object({\n  content: ['content', optional(string())],\n  contentLength: ['contentLength', optional(number())],\n  mediaName: ['mediaName', optional(string())],\n});\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { Schema, stringEnum } from '../schema';\n\n/**\n * Enum for PriorityEnum\n */\nexport enum PriorityEnum {\n  Default = 'default',\n  High = 'high',\n}\n\n/**\n * Schema for PriorityEnum\n */\nexport const priorityEnumSchema: Schema<PriorityEnum> = stringEnum(PriorityEnum);\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { array, object, optional, Schema, string } from '../schema';\nimport { PriorityEnum, priorityEnumSchema } from './priorityEnum';\n\nexport interface MessageRequest {\n  /** The ID of the Application your from number is associated with in the Bandwidth Phone Number Dashboard. */\n  applicationId: string;\n  /** The phone number(s) the message should be sent to in E164 format */\n  to: string[];\n  /** One of your telephone numbers the message should come from in E164 format */\n  from: string;\n  /** The contents of the text message. Must be 2048 characters or less. */\n  text?: string;\n  /** A list of URLs to include as media attachments as part of the message. */\n  media?: string[];\n  /** A custom string that will be included in callback events of the message. Max 1024 characters */\n  tag?: string;\n  /** The message's priority, currently for toll-free or short code SMS only. Messages with a priority value of `\"high\"` are given preference over your other traffic. */\n  priority?: PriorityEnum;\n}\n\nexport const messageRequestSchema: Schema<MessageRequest> = object({\n  applicationId: ['applicationId', string()],\n  to: ['to', array(string())],\n  from: ['from', string()],\n  text: ['text', optional(string())],\n  media: ['media', optional(array(string()))],\n  tag: ['tag', optional(string())],\n  priority: ['priority', optional(priorityEnumSchema)],\n});\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { ClientInterface, SdkRequestBuilderFactory } from '../clientInterface';\n\n/** Base class for all controllers */\nexport class BaseController {\n  /** Create a request builder */\n  protected createRequest: SdkRequestBuilderFactory;\n\n  constructor(client: ClientInterface) {\n    this.createRequest = client.getRequestBuilderFactory();\n  }\n}\n","/**\n * bandwidthLib\n *\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\n */\n\nimport { ApiResponse } from '../apiResponse';\nimport { MessagingExceptionError } from '../errors/messagingExceptionError';\nimport { FileWrapper } from '../fileWrapper';\nimport { RequestOptions } from '../http/requestBuilder';\nimport {\n  BandwidthMessage,\n  bandwidthMessageSchema,\n} from '../models/bandwidthMessage';\nimport {\n  BandwidthMessagesList,\n  bandwidthMessagesListSchema,\n} from '../models/bandwidthMessagesList';\nimport { Media, mediaSchema } from '../models/media';\nimport { MessageRequest, messageRequestSchema } from '../models/messageRequest';\nimport { array, number, optional, string } from '../schema';\nimport { BaseController } from './baseController';\n\nexport class ApiController extends BaseController {\n  /**\n   * listMedia\n   *\n   * @param accountId          User's account ID\n   * @param continuationToken  Continuation token used to retrieve subsequent media.\n   * @return Response from the API call\n   */\n  async listMedia(\n    accountId: string,\n    continuationToken?: string,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<Media[]>> {\n    const req = this.createRequest('GET');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      continuationToken: [continuationToken, optional(string())],\n    });\n    req.header('Continuation-Token', mapped.continuationToken);\n    req.appendTemplatePath`/users/${mapped.accountId}/media`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.callAsJson(array(mediaSchema), requestOptions);\n  }\n\n  /**\n   * getMedia\n   *\n   * @param accountId User's account ID\n   * @param mediaId   Media ID to retrieve\n   * @return Response from the API call\n   */\n  async getMedia(\n    accountId: string,\n    mediaId: string,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>> {\n    const req = this.createRequest('GET');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      mediaId: [mediaId, string()],\n    });\n    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.callAsStream(requestOptions);\n  }\n\n  /**\n   * uploadMedia\n   *\n   * @param accountId     User's account ID\n   * @param mediaId       The user supplied custom media ID\n   * @param body\n   * @param contentType   The media type of the entity-body\n   * @param cacheControl  General-header field is used to specify directives that MUST be obeyed by all\n   *                                     caching mechanisms along the request/response chain.\n   * @return Response from the API call\n   */\n  async uploadMedia(\n    accountId: string,\n    mediaId: string,\n    body: FileWrapper,\n    contentType?: string,\n    cacheControl?: string,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<void>> {\n    const req = this.createRequest('PUT');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      mediaId: [mediaId, string()],\n      contentType: [contentType, optional(string())],\n      cacheControl: [cacheControl, optional(string())],\n    });\n    req.header('Content-Type', mapped.contentType);\n    req.header('Cache-Control', mapped.cacheControl);\n    req.stream(body);\n    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.call(requestOptions);\n  }\n\n  /**\n   * deleteMedia\n   *\n   * @param accountId User's account ID\n   * @param mediaId   The media ID to delete\n   * @return Response from the API call\n   */\n  async deleteMedia(\n    accountId: string,\n    mediaId: string,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<void>> {\n    const req = this.createRequest('DELETE');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      mediaId: [mediaId, string()],\n    });\n    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.call(requestOptions);\n  }\n\n  /**\n   * getMessages\n   *\n   * @param accountId     User's account ID\n   * @param messageId     The ID of the message to search for. Special characters need to be encoded using\n   *                                URL encoding\n   * @param sourceTn      The phone number that sent the message\n   * @param destinationTn The phone number that received the message\n   * @param messageStatus The status of the message. One of RECEIVED, QUEUED, SENDING, SENT, FAILED,\n   *                                DELIVERED, ACCEPTED, UNDELIVERED\n   * @param errorCode     The error code of the message\n   * @param fromDateTime  The start of the date range to search in ISO 8601 format. Uses the message receive\n   *                                time. The date range to search in is currently 14 days.\n   * @param toDateTime    The end of the date range to search in ISO 8601 format. Uses the message receive\n   *                                time. The date range to search in is currently 14 days.\n   * @param pageToken     A base64 encoded value used for pagination of results\n   * @param limit         The maximum records requested in search result. Default 100. The sum of limit and\n   *                                after cannot be more than 10000\n   * @return Response from the API call\n   */\n  async getMessages(\n    accountId: string,\n    messageId?: string,\n    sourceTn?: string,\n    destinationTn?: string,\n    messageStatus?: string,\n    errorCode?: number,\n    fromDateTime?: string,\n    toDateTime?: string,\n    pageToken?: string,\n    limit?: number,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<BandwidthMessagesList>> {\n    const req = this.createRequest('GET');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      messageId: [messageId, optional(string())],\n      sourceTn: [sourceTn, optional(string())],\n      destinationTn: [destinationTn, optional(string())],\n      messageStatus: [messageStatus, optional(string())],\n      errorCode: [errorCode, optional(number())],\n      fromDateTime: [fromDateTime, optional(string())],\n      toDateTime: [toDateTime, optional(string())],\n      pageToken: [pageToken, optional(string())],\n      limit: [limit, optional(number())],\n    });\n    req.query('messageId', mapped.messageId);\n    req.query('sourceTn', mapped.sourceTn);\n    req.query('destinationTn', mapped.destinationTn);\n    req.query('messageStatus', mapped.messageStatus);\n    req.query('errorCode', mapped.errorCode);\n    req.query('fromDateTime', mapped.fromDateTime);\n    req.query('toDateTime', mapped.toDateTime);\n    req.query('pageToken', mapped.pageToken);\n    req.query('limit', mapped.limit);\n    req.appendTemplatePath`/users/${mapped.accountId}/messages`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.callAsJson(bandwidthMessagesListSchema, requestOptions);\n  }\n\n  /**\n   * createMessage\n   *\n   * @param accountId User's account ID\n   * @param body\n   * @return Response from the API call\n   */\n  async createMessage(\n    accountId: string,\n    body: MessageRequest,\n    requestOptions?: RequestOptions\n  ): Promise<ApiResponse<BandwidthMessage>> {\n    const req = this.createRequest('POST');\n    const mapped = req.prepareArgs({\n      accountId: [accountId, string()],\n      body: [body, messageRequestSchema],\n    });\n    req.json(mapped.body);\n    req.appendTemplatePath`/users/${mapped.accountId}/messages`;\n    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');\n    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');\n    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');\n    req.throwOn(404, MessagingExceptionError, '404 Path not found');\n    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');\n    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');\n    return req.callAsJson(bandwidthMessageSchema, requestOptions);\n  }\n}\n"],"names":["Environment","passThroughInterceptor","request","requestOptions","next","DEFAULT_CONFIGURATION","timeout","environment","Production","baseUrl","basicAuthUserName","basicAuthPassword","ApiError","Error","constructor","context","message","super","response","this","statusCode","headers","body","JSON","JSONBig","useNativeBigInt","result","parse","error","isBlob","value","Blob","Object","prototype","toString","call","AbortError","FileWrapper","file","options","isFileWrapper","cloneFileWrapper","fileWrapper","fileWrapperOptions","clone","cloneFileWrapperOptions","setHeader","name","setHeaderInternal","lookupCaseInsensitive","realHeaderName","setHeaderIfNotSet","obj","prop","toLowerCase","p","hasOwnProperty","mergeHeaders","headersToMerge","headerKeys","headerName","getOwnPropertyNames","lowerCasedName","indexedPrefix","prefix","key","formDataEncodeObject","prefixFormat","keys","push","Array","isArray","iter","length","[object Object]","objectKey","element","urlEncodeKeyValuePairs","params","encode","encodeURIComponent","map","join","DEFAULT_AXIOS_CONFIG_OVERRIDES","transformResponse","HttpClient","clientConfigOverrides","_timeout","_axiosInstance","axios","create","convertHttpRequest","req","newRequest","method","url","responseType","auth","username","password","requestBody","type","data","content","some","item","form","FormData","_iter$value$options","fileData","contentType","append","getHeaders","_requestBody$content$","isNode","validateStatus","convertHttpResponse","resp","status","axiosRequest","abortSignal","aborted","abortError","cancelToken","CancelToken","source","token","addEventListener","cancel","isCancel","SkipEncode","pathTemplate","strings","args","flatMap","a","b","min","Math","apply","reduce","_","index","concat","slice","interweaveArrays","s","encodePathTemplateSegment","skipEncode","m","ArgumentsValidationError","errors","errorKeys","msgList","param","ResponseValidationError","apiResponse","e","i","prepareArgs","validationErrors","paramName","paramInfo","validationResult","validateAndUnmap","DefaultRequestBuilder","_httpClient","_baseUrlProvider","_apiErrorFactory","_authenticationProvider","_httpMethod","_path","_headers","_query","_interceptors","_validateResponse","_addResponseValidator","_addAuthentication","bind","authenticate","_authParams","deprecated","methodName","appendTemplatePath","pathSegment","appendPath","httpMethodName","arg","_baseUrlArg","path","mergePath","acceptJson","_accept","accept","acceptHeaderValue","contentTypeHeaderValue","_contentType","header","undefined","query","nameOrParameters","queryString","text","_body","_setContentTypeIfNotSet","json","stringify","xml","argName","rootName","schema","mappingResult","validateAndUnmapXml","_rootName","_value","xmlSerialize","stream","_stream","parameters","_form","filter","formData","_formData","toRequest","indexOf","match","protocol","substring","replace","sanitizeUrl","intercept","interceptor","interceptRequest","opt","interceptResponse","async","defaultToError","apiErrorCtor","validateResponse","validate","throwOn","errorConstructor","pipeline","interceptors","client","current","last","callHttpInterceptors","convertToStream","parsed","validateAndMap","xmlObject","_xmlString","xmlDeserialize","validateAndMapXml","handler","left","right","substr","rs","require","_read","Client","config","baseUrlProvider","authProvider","httpClient","addons","_config","_requestBuilderFactory","server","Custom","getBaseUri","basicAuthAuthenticationProvider","requiresAuth","unstable_httpClientOptions","withErrorHandlers","withUserAgent","withAuthenticationByDefault","requestBuilderFactory","callback","requestBuilder","forEach","c","tap","apiErrorFactory","authenticationProvider","httpMethod","createRequestBuilderFactory","executeRequest","getRequestBuilderFactory","withConfiguration","rb","MessagingExceptionError","bandwidthMessageSchema","object","id","optional","string","owner","applicationId","time","segmentCount","number","direction","to","array","from","media","tag","priority","bandwidthMessageItemSchema","messageId","accountId","sourceTn","destinationTn","messageStatus","messageDirection","messageType","errorCode","receiveTime","carrierName","nullable","pageInfoSchema","prevPage","nextPage","prevPageToken","nextPageToken","bandwidthMessagesListSchema","totalCount","pageInfo","lazy","messages","mediaSchema","contentLength","mediaName","PriorityEnum","priorityEnumSchema","stringEnum","messageRequestSchema","createRequest","continuationToken","mapped","callAsJson","mediaId","callAsStream","cacheControl","fromDateTime","toDateTime","pageToken","limit"],"mappings":"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"}