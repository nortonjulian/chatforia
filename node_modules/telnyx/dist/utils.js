"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeURLInterpolator = void 0;
exports.isAuthKey = isAuthKey;
exports.isJsonString = isJsonString;
exports.isObject = isObject;
exports.isOptionsHash = isOptionsHash;
exports.removeEmpty = removeEmpty;
exports.snakeToCamelCase = snakeToCamelCase;
exports.callbackifyPromiseWithTimeout = callbackifyPromiseWithTimeout;
exports.addResourceToResponseData = addResourceToResponseData;
exports.createNestedMethods = createNestedMethods;
exports.getDataFromArgs = getDataFromArgs;
exports.getOptionsFromArgs = getOptionsFromArgs;
exports.emitWarning = emitWarning;
exports.toSingular = toSingular;
exports.pascalToCamelCase = pascalToCamelCase;
exports.stringifyRequestData = stringifyRequestData;
exports.flattenAndStringify = flattenAndStringify;
exports.protoExtend = protoExtend;
exports.tryParseJSON = tryParseJSON;
const qs = __importStar(require("qs"));
const OPTIONS_KEYS = ['api_key'];
function isAuthKey(key) {
    return (typeof key == 'string' && /^KEY[A-Z0-9]{32}_[a-zA-Z0-9]{22}$/.test(key));
}
function isJsonString(str) {
    try {
        if (!str || str.includes('filter[tag]=')) {
            return false;
        }
        JSON.parse(str);
    }
    catch (_e) {
        return false;
    }
    return true;
}
function isObject(obj) {
    const type = typeof obj;
    return (type === 'function' || type === 'object') && !!obj;
}
function isOptionsHash(o) {
    return (o &&
        typeof o === 'object' &&
        OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o, prop)));
}
/**
 * Remove empty values from an object
 */
function removeEmpty(obj) {
    if (typeof obj !== 'object') {
        throw new Error('Argument must be an object');
    }
    Object.keys(obj).forEach(function (key) {
        if (obj[key] === null || obj[key] === undefined) {
            delete obj[key];
        }
    });
    return obj;
}
/**
 * snake_case to camelCase
 */
function snakeToCamelCase(name) {
    const words = name.split('_');
    return words.reduce(function (acc, nextWord) {
        return acc + nextWord.charAt(0).toUpperCase() + nextWord.slice(1);
    });
}
function callbackifyPromiseWithTimeout(promise, callback) {
    if (callback) {
        // Ensure callback is called outside of promise stack.
        return promise.then((res) => {
            setTimeout(() => {
                callback(null, res);
            }, 0);
        }, (err) => {
            setTimeout(() => {
                callback(err, null);
            }, 0);
        });
    }
    return promise;
}
/**
 * Add TelnyxResource to API response data
 *
 * @param [response] Resource response object
 * @param [telnyx] Telnyx SDK
 * @param [resourceName] Resource name in camelCase
 * @param [methods] resource methods to include
 */
function addResourceToResponseData(response, telnyx, resourceName, methods) {
    if (response && response.data && typeof response.data === 'object') {
        /*
         * make nested methods. e.g.: call.bridge();
         * nested methods should be used from basic methods response. See specs for an example
         */
        const resourceFulData = telnyx[resourceName];
        Object.assign(resourceFulData, response.data, methods);
        response.data = resourceFulData;
    }
    return response;
}
/**
 * Create multiple nested methods, in camelCase and snakeCase, using spec and method names
 *
 * @param [telnyxMethod] TelnyxResource Method  telnyxMethod creator
 * @param [names=[]] Array of method names
 * @param [spec] telnyxMethod spec creator by method name
 */
function createNestedMethods(telnyxMethod, names, spec) {
    const methods = {};
    names.forEach(function (name) {
        methods[name] = methods[snakeToCamelCase(name)] = telnyxMethod(spec(name));
    });
    return methods;
}
/**
 * Return the data argument from a list of arguments
 *
 * @param {object[]} args
 * @returns {object}
 */
function getDataFromArgs(args) {
    if (!Array.isArray(args) || !args[0] || typeof args[0] !== 'object') {
        return {};
    }
    if (!isOptionsHash(args[0])) {
        return args.shift();
    }
    const argKeys = Object.keys(args[0]);
    const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
    // In some cases options may be the provided as the first argument.
    // Here we're detecting a case where there are two distinct arguments
    // (the first being args and the second options) and with known
    // option keys in the first so that we can warn the user about it.
    if (optionKeysInArgs.length > 0 &&
        optionKeysInArgs.length !== argKeys.length) {
        emitWarning(`Options found in arguments (${optionKeysInArgs.join(', ')}). Did you mean to pass an options object?`);
    }
    return {};
}
/**
 * Return the options hash from a list of arguments
 */
function getOptionsFromArgs(args) {
    const opts = {
        auth: null,
        headers: {},
    };
    if (args.length > 0) {
        const arg = args[args.length - 1];
        if (isAuthKey(arg)) {
            opts.auth = args.pop();
        }
        else if (isOptionsHash(arg)) {
            const params = { ...args.pop() };
            const extraKeys = Object.keys(params).filter(function (key) {
                return OPTIONS_KEYS.indexOf(key) == -1;
            });
            if (extraKeys.length) {
                emitWarning('Invalid options found (' + extraKeys.join(', ') + '); ignoring.');
            }
            if (params.api_key) {
                opts.auth = params.apiKey;
            }
        }
    }
    return opts;
}
function emitWarning(warning) {
    if (typeof process.emitWarning !== 'function') {
        return console.warn(`Telnyx: ${warning}`); /* eslint-disable-line no-console */
    }
    return process.emitWarning(warning, 'Telnyx');
}
function toSingular(name) {
    if (name.endsWith('s')) {
        return name.slice(0, -1);
    }
    return name;
}
/**
 * Allow for special capitalization cases (such as OAuth)
 */
function pascalToCamelCase(name) {
    return name[0]?.toLowerCase() + name.substring(1);
}
function stringifyRequestData(data) {
    return (qs
        .stringify(data, {
        arrayFormat: 'brackets',
        serializeDate: (d) => Math.floor(d.getTime() / 1000).toString(),
    })
        // Don't use strict form encoding by changing the square bracket control
        // characters back to their literals. This is fine by the server, and
        // makes these parameter strings easier to read.
        .replace(/%5B/g, '[')
        .replace(/%5D/g, ']'));
}
// For use in multipart requests
function flattenAndStringify(data) {
    const result = {};
    const step = (obj, prevKey) => {
        Object.entries(obj).forEach(([key, value]) => {
            const newKey = prevKey ? `${prevKey}[${key}]` : key;
            if (isObject(value)) {
                if (!(value instanceof Uint8Array) &&
                    !Object.prototype.hasOwnProperty.call(value, 'data')) {
                    // Non-buffer non-file Objects are recursively flattened
                    return step(value, newKey);
                }
                else {
                    // Buffers and file objects are stored without modification
                    result[newKey] = value;
                }
            }
            else {
                // Primitives are converted to strings
                result[newKey] = String(value);
            }
        });
    };
    step(data, null);
    return result;
}
/**
 * Outputs a new function with interpolated object property values.
 * Use like so:
 *   const fn = makeURLInterpolator('some/url/{param1}/{param2}');
 *   fn({ param1: 123, param2: 456 }); // => 'some/url/123/456'
 */
exports.makeURLInterpolator = (() => {
    const rc = {
        '\n': '\\n',
        '"': '\\"',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
    };
    return (str) => {
        const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc[$0] || '');
        return (outputs) => {
            return cleanString.replace(/\{([\s\S]+?)\}/g, (_$0, $1) => 
            // @ts-expect-error TODO: cast outputs to string
            encodeURIComponent(outputs[$1] || ''));
        };
    };
})();
/**
 * Provide simple "Class" extension mechanism.
 * <!-- Public API accessible via Telnyx.TelnyxResource.extend -->
 */
function protoExtend(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
sub) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const Super = this;
    const Constructor = Object.prototype.hasOwnProperty.call(sub, 'constructor')
        ? sub.constructor
        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function (...args) {
                Super.apply(this, args);
            };
    // This initialization logic is somewhat sensitive to be compatible with
    // divergent JS implementations like the one found in Qt. See here for more
    // context:
    //
    // https://github.com/team-telnyx/telnyx-node/pull/179
    Object.assign(Constructor, Super);
    Constructor.prototype = Object.create(Super.prototype);
    Object.assign(Constructor.prototype, sub);
    return Constructor;
}
/**
 * tryParseJSON used to only parse JSON response,
 * if it is not a JSON response sends the value inside a data object to keep the standard.
 *
 * @param [jsonString]  Response object
 */
function tryParseJSON(jsonString) {
    try {
        if (jsonString === '') {
            const defaultValue = {
                data: jsonString,
            };
            return defaultValue;
        }
        return JSON.parse(jsonString);
    }
    catch (_e) {
        const defaultValue = {
            data: jsonString,
        };
        return defaultValue;
    }
}
