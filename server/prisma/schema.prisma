// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AutoResponderMode {
  off
  dm // only in 1:1 chats
  mention // only when @username is mentioned
  all // any inbound msg in any room
}

model User {
  id                          Int     @id @default(autoincrement())
  username                    String  @unique
  email                       String? @unique
  password                    String
  phoneNumber                 String? @db.VarChar(32)
  preferredLanguage           String  @default("en")
  allowExplicitContent        Boolean @default(true)
  showOriginalWithTranslation Boolean @default(true)
  role                        String  @default("USER")
  enableAIResponder           Boolean @default(false)
  enableSmartReplies          Boolean @default(false)

  autoResponderMode        AutoResponderMode @default(dm)
  autoResponderCooldownSec Int               @default(120)
  autoResponderActiveUntil DateTime?
  autoResponderSignature   String? // e.g. "ü§ñ Auto-reply"

  // Encryption key
  publicKey  String? // for E2EE
  privateKey String? // (optional for now ‚Äî may not store this in DB)

  // Relations
  messages          Message[]        @relation("UserMessages") // Messages sent by the user
  participants      Participant[] // User's membership in chat rooms
  reports           Report[]         @relation("UserReports") // NEW backreference
  randomChatRooms   RandomChatRoom[] @relation("RandomChatParticipants") // For random chat pairing
  autoDeleteSeconds Int?
  showReadReceipts  Boolean          @default(true)
  readMessages      Message[]        @relation("ReadMessages")
  avatarUrl         String?
  emojiTag          String?

  // ‚úÖ New backrelations
  contactsOwned Contact[] @relation("ContactsOwned")
  contactsSaved Contact[] @relation("ContactsSaved")

  auditLogs AuditLog[] @relation("AuditActor")

  messageKeys MessageKey[]

  // ‚úÖ back-relation for Device.user
  devices           Device[]
  // If you keep a "revokedBy" relation, add the named back-relation too:
  deviceRevocations Device[] @relation("DeviceRevokedBy")

   // back-relation to invites the user created
  createdInvites  ChatRoomInvite[]    @relation("InviteCreator")
}

enum AutoTranslateMode {
  off
  tagged
  all
}

enum AIAssistantMode {
  off
  mention
  always
}

enum RoomRole {
  MEMBER
  MODERATOR
  ADMIN
}

model ChatRoom {
  id   Int     @id @default(autoincrement())
  name String?

  aiAssistantMode AIAssistantMode @default(off)
  isGroup         Boolean         @default(false)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  participants Participant[] // Users in this chatroom (via join table)
  messages     Message[]     @relation("ChatRoomMessages") // Standard chat messages

  autoTranslateMode AutoTranslateMode @default(off)
  allowOrbitBot     Boolean           @default(false)

  // back-relation to room invites
  invites   ChatRoomInvite[]   @relation("RoomInvites")
}

model Participant {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id])
  chatRoomId Int

  role RoomRole @default(MEMBER)

  joinedAt   DateTime @default(now())
  allowAIBot Boolean  @default(true)

  @@unique([userId, chatRoomId]) // Each user can only be in a chatroom once
  @@index([chatRoomId, role])
}

enum AttachmentKind {
  IMAGE
  VIDEO
  AUDIO
  FILE
}

model Message {
  id                Int       @id @default(autoincrement())
  contentCiphertext String
  rawContent        String
  translations      Json?
  translatedFrom    String?
  isExplicit        Boolean   @default(false)
  imageUrl          String?
  audioUrl           String?   
  audioDurationSec   Int?      
  expiresAt         DateTime?
  deletedBySender   Boolean   @default(false)

  sender     User     @relation("UserMessages", fields: [senderId], references: [id])
  senderId   Int
  chatRoom   ChatRoom @relation("ChatRoomMessages", fields: [chatRoomId], references: [id])
  chatRoomId Int

  // NEW: keys live in a separate table
  keys MessageKey[]

  attachments   MessageAttachment[]

  randomChatRoomId Int?
  randomChatRoom   RandomChatRoom? @relation(fields: [randomChatRoomId], references: [id])

  createdAt DateTime @default(now())
  readBy    User[]   @relation("ReadMessages")
  reports   Report[]

  isAutoReply Boolean @default(false)

  @@index([expiresAt])
  @@index([chatRoomId, createdAt])
}

// one row per (message, recipient)
model MessageKey {
  messageId    Int
  userId       Int
  // base64 of [nonce(24) | box]; exactly what you produce today
  encryptedKey String

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId]) // composite PK (fast lookups)
  @@index([userId])
}

model MessageAttachment {
  id             Int            @id @default(autoincrement())
  message        Message        @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId      Int
  kind           AttachmentKind
  url            String
  mimeType       String
  width          Int?
  height         Int?
  durationSec    Int?
  caption        String?
  createdAt      DateTime       @default(now())

  @@index([messageId])
}

model RandomChatRoom {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Users connected for random chat
  participants User[] @relation("RandomChatParticipants")

  // Messages sent in this random chat
  messages  Message[]
  aiEnabled Boolean   @default(false) // Per-chat toggle for AI bot
}

model Contact {
  id Int @id @default(autoincrement())

  // Owner (the person who saved the contact)
  ownerId Int
  owner   User @relation("ContactsOwned", fields: [ownerId], references: [id], onDelete: Cascade)

  // Linked app user (optional)
  userId Int?
  user   User? @relation("ContactsSaved", fields: [userId], references: [id])

  // External contact fields (for people who don't have an account yet)
  externalPhone String? @db.VarChar(32)
  externalName  String?

  alias     String?
  favorite  Boolean  @default(false)
  createdAt DateTime @default(now())

  // Prevent duplicates for the owner:
  @@unique([ownerId, userId]) // ok even when userId is nullable (Postgres allows multiple NULLs)
  @@unique([ownerId, externalPhone])
  @@index([ownerId])
  @@index([userId])
}

model Report {
  id               Int      @id @default(autoincrement())
  messageId        Int
  reporterId       Int
  decryptedContent String
  createdAt        DateTime @default(now())

  // Strings instead of enum
  status     String    @default("OPEN") // "OPEN" | "RESOLVED" | "ACTIONED"
  resolvedAt DateTime?
  notes      String?

  message  Message @relation(fields: [messageId], references: [id])
  reporter User    @relation("UserReports", fields: [reporterId], references: [id])

  @@index([status, createdAt])
}

model AuditLog {
  id      Int  @id @default(autoincrement())
  actorId Int
  actor   User @relation("AuditActor", fields: [actorId], references: [id], onDelete: Cascade)

  action     String // e.g., "users.list", "users.ban", "messages.delete"
  resource   String? // e.g., "user", "message", "chatroom"
  resourceId String? // string so we can store UUIDs or composite keys
  status     Int // HTTP status code of the request when logged
  ip         String?
  userAgent  String?
  metadata   Json? // optional redacted/structured context (never raw PII)
  createdAt  DateTime @default(now())

  @@index([actorId, createdAt])
  @@index([action, createdAt])
}

model Device {
  // keep string IDs for devices if you like
  id String @id @default(cuid())

  // ‚úÖ match the User.id type
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  publicKey  String
  name       String?
  platform   String?
  isPrimary  Boolean   @default(false)
  createdAt  DateTime  @default(now())
  lastSeenAt DateTime?
  revokedAt  DateTime?

  // Optional: who revoked it
  revokedById Int?
  revokedBy   User? @relation("DeviceRevokedBy", fields: [revokedById], references: [id])

  @@index([userId])
}

model ProvisionLink {
  id          String    @id @default(cuid())
  userId      String
  createdById String
  secret      String // random 32 bytes (base64)
  expiresAt   DateTime // e.g., now()+10m
  usedAt      DateTime?
  sasCode     String // 6-digit Short Authentication String for human verify
  createdAt   DateTime  @default(now())

  // cleanup with a cron/job
  @@index([userId])
}

model MessageSessionKey {
  id                  String @id @default(cuid())
  messageId           String
  recipientUserId     String
  recipientDeviceId   String
  encryptedSessionKey String // encrypted to that device's public key
}

model ChatRoomInvite {
  id           Int       @id @default(autoincrement())
  code         String    @unique

  chatRoomId   Int
  chatRoom     ChatRoom  @relation("RoomInvites", fields: [chatRoomId], references: [id], onDelete: Cascade)

  createdById  Int
  createdBy    User      @relation("InviteCreator", fields: [createdById], references: [id])

  maxUses      Int       @default(0)   // 0 = unlimited
  uses         Int       @default(0)
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
}

model MessageReaction {
  messageId Int
  userId    Int
  emoji     String   // store raw emoji (üëç, ‚ù§Ô∏è) or shortcodes (":thumbsup:")
  createdAt DateTime @default(now())

  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId, emoji]) // dedupe: a user can react once per emoji per message
}
