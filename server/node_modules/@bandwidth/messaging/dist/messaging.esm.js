import JSONBig from 'json-bigint';
import axios from 'axios';
import isNode from 'detect-node';
import FormData from 'form-data';
import warning from 'tiny-warning';
import flatMap from 'lodash.flatmap';
import { validateAndUnmap, validateAndUnmapXml, validateAndMap, validateAndMapXml, object, optional, string, number, array, nullable, lazy, stringEnum } from '@apimatic/schema';

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Calls HTTP interceptor chain
 *
 * @param interceptors HTTP interceptor chain
 * @param client Terminating HTTP handler
 */
function callHttpInterceptors(interceptors, client) {
  let next = client;
  for (let index = interceptors.length - 1; index >= 0; index--) {
    const current = interceptors[index];
    const last = next;
    next = (request, options) => current(request, options, last);
  }
  return next;
}
/** Pass-through HTTP interceptor. */
function passThroughInterceptor(request, requestOptions, next) {
  return next(request, requestOptions);
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const basicAuthAuthenticationProvider = ({
  basicAuthUserName,
  basicAuthPassword
}) => {
  return requiresAuth => {
    if (!requiresAuth) {
      return passThroughInterceptor;
    }
    return (request, options, next) => {
      request.auth = {
        username: basicAuthUserName,
        password: basicAuthPassword
      };
      return next(request, options);
    };
  };
};

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/** Environments available for API */
var Environment;
(function (Environment) {
  Environment["Production"] = "production";
  Environment["Custom"] = "custom";
})(Environment || (Environment = {}));

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/** Default values for the configuration parameters of the client. */
const DEFAULT_CONFIGURATION = {
  timeout: 0,
  environment: Environment.Production,
  baseUrl: 'https://www.example.com',
  basicAuthUserName: 'TODO access token',
  basicAuthPassword: 'TODO access token'
};

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Thrown when the HTTP status code is not okay.
 *
 * The ApiError extends the ApiResponse interface, so all ApiResponse
 * properties are available.
 */
class ApiError extends Error {
  constructor(context, message) {
    super(message);
    const {
      request,
      response
    } = context;
    this.request = request;
    this.statusCode = response.statusCode;
    this.headers = response.headers;
    this.body = response.body;
    if (typeof response.body === 'string' && response.body !== '') {
      const JSON = JSONBig({
        useNativeBigInt: true
      });
      try {
        this.result = JSON.parse(response.body);
      } catch (error) {
        if (process.env.NODE_ENV !== "production") {
          if (console) {
            console.warn(`Unexpected error: Could not parse HTTP response body as JSON. ${error.message}`);
          }
        }
      }
    }
  }
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Validates the protocol and removes duplicate forward slashes
 *
 * @param url URL to clean
 * @returns Sanitized URL
 */
function sanitizeUrl(url) {
  // ensure that the urls are absolute
  const protocolRegex = /^https?:\/\/[^/]+/;
  const match = url.match(protocolRegex);
  if (match === null) {
    throw new Error(`Invalid URL format: ${url}`);
  }
  // remove redundant double-forward slashes
  const protocol = match[0];
  const queryUrl = url.substring(protocol.length).replace(/\/\/+/g, '/');
  return protocol + queryUrl;
}
/**
 * Check whether value is an instance of Blob
 *
 * @remark
 * Reference: https://github.com/sindresorhus/is-blob/blob/master/index.js
 *
 * @param value Value to check
 * @returns True if the value is a Blob instance
 */
function isBlob(value) {
  if (typeof Blob === 'undefined') {
    return false;
  }
  return value instanceof Blob || Object.prototype.toString.call(value) === '[object Blob]';
}
// This is used by deprecated() to keep track of "hits".
const deprecatedHits = {};
/**
 * Create warning for deprecated method usage.
 *
 * This is called once per deprecated method. If this method is called again
 * with the same arguments, no warning is generated.
 *
 * @param methodName Method name for deprecated method
 * @param notice Optional message for deprecation
 */
function deprecated(methodName, notice) {
  let message = `Method ${methodName} is deprecated.`;
  if (notice) {
    message += ` ${notice}`;
  }
  if (deprecatedHits[message]) {
    return;
  }
  deprecatedHits[message] = true;
  process.env.NODE_ENV !== "production" ? warning(false, message) : void 0;
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Thrown when the API call is aborted by the caller.
 *
 * Note that when an AbortError is thrown, it is not a guarantee that the API call
 * did not go through.
 */
class AbortError extends Error {}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Wraps file with mime-type and filename to be sent as part of an HTTP request.
 */
class FileWrapper {
  constructor(file, options) {
    this.file = file;
    this.options = options;
    this.file = file;
  }
}
/** Returns true if value is a FileWrapper */
function isFileWrapper(value) {
  return value instanceof FileWrapper;
}
/**
 * Returns a deep clone of the FileWrapper instance
 *
 * @param fileWrapper FileWrapper instance to copy
 */
function cloneFileWrapper(fileWrapper) {
  let options;
  if (fileWrapper.options) {
    options = cloneFileWrapperOptions(fileWrapper.options);
  }
  return new FileWrapper(fileWrapper.file, options);
}
function cloneFileWrapperOptions(fileWrapperOptions) {
  const clone = {
    ...fileWrapperOptions
  };
  if (fileWrapperOptions.headers) {
    clone.headers = {
      ...fileWrapperOptions.headers
    };
  }
  return clone;
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Set a header in the headers map.
 *
 * This method performs case-insensitive handling of header names.
 *
 * @param headers Map of headers
 * @param name Header name
 * @param value Header value
 */
function setHeader(headers, name, value) {
  const realHeaderName = lookupCaseInsensitive(headers, name);
  setHeaderInternal(headers, realHeaderName, name, value);
}
function setHeaderInternal(headers, realHeaderName, name, value) {
  if (realHeaderName) {
    delete headers[realHeaderName];
  }
  if (value) {
    headers[name] = value;
  }
}
/**
 * Set a header in the headers map if it is not already set.
 *
 * This method performs case-insensitive handling of header names.
 *
 * @param headers Map of headers
 * @param name Header name
 * @param value Header value
 */
function setHeaderIfNotSet(headers, name, value) {
  const realHeaderName = lookupCaseInsensitive(headers, name);
  if (!realHeaderName) {
    setHeaderInternal(headers, realHeaderName, name, value);
  }
}
/**
 * Looks up and returns the matching property name from the object.
 *
 * This method returns the matching property name in the object which might or might
 * not have the same case as the prop argument.
 *
 * @param obj Object with string property names
 * @param prop Property to lookup
 */
function lookupCaseInsensitive(obj, prop) {
  prop = prop.toLowerCase();
  for (const p in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, p) && prop === p.toLowerCase()) {
      return p;
    }
  }
  return null;
}
/**
 * Merge headers
 *
 * Header names are compared using case-insensitive comparison. This method
 * preserves the original header name. If the headersToMerge overrides an existing
 * header, then the new header name (with its casing) is used.
 *
 * @param headers Headers to merge into
 * @param headersToMerge Headers to set
 */
function mergeHeaders(headers, headersToMerge) {
  const headerKeys = {};
  // Create a map of lower-cased-header-name to original-header-names
  for (const headerName of Object.getOwnPropertyNames(headers)) {
    headerKeys[headerName.toLowerCase()] = headerName;
  }
  // Override headers with new values
  for (const headerName of Object.getOwnPropertyNames(headersToMerge)) {
    const lowerCasedName = headerName.toLowerCase();
    if (headerKeys[lowerCasedName]) {
      delete headers[headerKeys[lowerCasedName]];
    }
    headerKeys[lowerCasedName] = headerName;
    headers[headerName] = headersToMerge[headerName];
  }
}
const CONTENT_TYPE_HEADER = 'content-type';
const ACCEPT_HEADER = 'accept';
const CONTENT_LENGTH_HEADER = 'content-length';
const FORM_URLENCODED_CONTENT_TYPE = 'application/x-www-form-urlencoded';
const JSON_CONTENT_TYPE = 'application/json';
const TEXT_CONTENT_TYPE = 'text/plain; charset=utf-8';
const XML_CONTENT_TYPE = 'application/xml';

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Array prefix format: item[1]=1&item[2]=2
 */
const indexedPrefix = (prefix, key) => `${prefix}[${key}]`;
/**
 * Converts an object to a list of key-value pairs for form-urlencoded serialization.
 *
 * @param obj The object to serialize
 * @param prefixFormat Formatting function to create key for nested arrays
 * @return Result of serialization
 */
function formDataEncodeObject(obj, prefixFormat = indexedPrefix) {
  const result = [];
  for (const key of Object.keys(obj)) {
    const value = obj[key];
    if (value === null || value === undefined) {
      continue;
    } else if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {
      result.push({
        key,
        value: value.toString()
      });
    } else if (isFileWrapper(value)) {
      result.push({
        key,
        value: cloneFileWrapper(value)
      });
    } else if (Array.isArray(value)) {
      for (let iter = 0; iter < value.length; iter += 1) {
        result.push(...formDataEncodeObject({
          [prefixFormat(key, iter)]: value[iter]
        }));
      }
    } else if (typeof value === 'object') {
      for (const objectKey in value) {
        if (Object.prototype.hasOwnProperty.call(value, objectKey)) {
          const element = value[objectKey];
          result.push(...formDataEncodeObject({
            [indexedPrefix(key, objectKey)]: element
          }));
        }
      }
    }
  }
  return result;
}
/**
 * Return a new list with all key-value pairs, which have a FileWrapper as value, removed
 *
 * @param params List of key-value pairs
 */
function filterFileWrapperFromKeyValuePairs(params) {
  return params.filter(p => !isFileWrapper(p.value));
}
/**
 * Serializes an object for a form-urlencoded request.
 *
 * Nested and complex types in values will be flattened using {@link formDataEncodeObject() function} method.
 *
 * @param  obj The object to be serialized
 * @return The result of serialization
 */
function urlEncodeObject(obj) {
  const params = formDataEncodeObject(obj);
  return urlEncodeKeyValuePairs(params);
}
/**
 * Serializes a list of key-value pairs for a form-urlencoded request.
 *
 * @param params List of key-value pairs to serialize
 * @return The result of serialization
 */
function urlEncodeKeyValuePairs(params) {
  const encode = encodeURIComponent;
  return (params || []).map(p => `${encode(p.key)}=${encode(p.value.toString())}`).join('&');
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const DEFAULT_AXIOS_CONFIG_OVERRIDES = {
  transformResponse: []
};
const DEFAULT_TIMEOUT = 30 * 1000;
/**
 * HTTP client implementation.
 *
 * This implementation is a wrapper over the Axios client.
 */
class HttpClient {
  constructor({
    clientConfigOverrides,
    timeout = DEFAULT_TIMEOUT
  } = {}) {
    this._timeout = timeout;
    this._axiosInstance = axios.create({
      ...DEFAULT_AXIOS_CONFIG_OVERRIDES,
      ...clientConfigOverrides
    });
  }
  /** Converts an HttpRequest object to an Axios request. */
  convertHttpRequest(req) {
    const newRequest = {
      method: req.method,
      url: req.url,
      responseType: 'text',
      headers: {
        ...req.headers
      }
    };
    if (req.auth) {
      // Set basic auth credentials if provided
      newRequest.auth = {
        username: req.auth.username,
        password: req.auth.password || ''
      };
    }
    const requestBody = req.body;
    if ((requestBody == null ? void 0 : requestBody.type) === 'text') {
      newRequest.data = requestBody.content;
    } else if ((requestBody == null ? void 0 : requestBody.type) === 'form-data' && requestBody.content.some(item => isFileWrapper(item.value))) {
      // Create multipart request if a file is present
      const form = new FormData();
      for (const iter of requestBody.content) {
        if (isFileWrapper(iter.value)) {
          var _iter$value$options;
          let fileData = iter.value.file;
          // Make sure Blob has the correct content type if provided
          if (isBlob(fileData) && (_iter$value$options = iter.value.options) != null && _iter$value$options.contentType) {
            fileData = new Blob([fileData], {
              type: iter.value.options.contentType
            });
          }
          form.append(iter.key, fileData, iter.value.options);
        } else {
          form.append(iter.key, iter.value);
        }
      }
      newRequest.data = form;
      mergeHeaders(newRequest.headers || {}, form.getHeaders());
    } else if ((requestBody == null ? void 0 : requestBody.type) === 'form-data' || (requestBody == null ? void 0 : requestBody.type) === 'form') {
      // Create form-urlencoded request
      setHeader(newRequest.headers || {}, CONTENT_TYPE_HEADER, FORM_URLENCODED_CONTENT_TYPE);
      newRequest.data = urlEncodeKeyValuePairs(requestBody.content);
    } else if ((requestBody == null ? void 0 : requestBody.type) === 'stream') {
      var _requestBody$content$;
      let contentType = 'application/octet-stream';
      if (isBlob(requestBody.content.file) && requestBody.content.file.type) {
        // Set Blob mime type as the content-type header if present
        contentType = requestBody.content.file.type;
      } else if ((_requestBody$content$ = requestBody.content.options) != null && _requestBody$content$.contentType) {
        // Otherwise, use the content type if available.
        contentType = requestBody.content.options.contentType;
      }
      setHeaderIfNotSet(newRequest.headers || {}, CONTENT_TYPE_HEADER, contentType);
      newRequest.data = requestBody.content.file;
    } else if (requestBody && typeof requestBody['type'] !== 'undefined') {
      throw new Error(`HTTP client encountered unknown body type '${requestBody["type"]}'. Could not execute HTTP request.`);
    }
    if (req.responseType === 'stream') {
      newRequest.responseType = isNode ? 'stream' : 'blob';
    }
    // Prevent superagent from converting any status code to error
    newRequest.validateStatus = () => true;
    // Set 30 seconds timeout
    newRequest.timeout = this._timeout;
    return newRequest;
  }
  /** Converts an Axios response to an HttpResponse object. */
  convertHttpResponse(resp) {
    return {
      body: resp.data,
      headers: resp.headers,
      statusCode: resp.status
    };
  }
  /**
   * Executes the HttpRequest with the given options and returns the HttpResponse
   * or throws an error.
   */
  async executeRequest(request, requestOptions) {
    const axiosRequest = this.convertHttpRequest(request);
    if (requestOptions != null && requestOptions.abortSignal) {
      // throw if already aborted; do not place HTTP call
      if (requestOptions.abortSignal.aborted) {
        throw this.abortError();
      }
      const cancelToken = axios.CancelToken.source();
      axiosRequest.cancelToken = cancelToken.token;
      // attach abort event handler
      requestOptions.abortSignal.addEventListener('abort', () => {
        cancelToken.cancel();
      });
    }
    try {
      return this.convertHttpResponse(await this._axiosInstance(axiosRequest));
    } catch (error) {
      // abort error should be thrown as the AbortError
      if (axios.isCancel(error)) {
        throw this.abortError();
      }
      throw error;
    }
  }
  abortError() {
    return new AbortError('The HTTP call was aborted.');
  }
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/** Marker for skipping URL-encoding when used with Path templating */
class SkipEncode {
  constructor(value) {
    this.value = value;
  }
}
/**
 * URL path templating method.
 *
 * Template arguments of array type are imploded using the path separator and
 * individual elements are URL-encoded.
 *
 * Template arguments are URL-encoded unless wrapped in a SkipEncode instance.
 */
function pathTemplate(strings, ...args) {
  const values = flatMap(interweaveArrays(strings.map(s => new SkipEncode(s)), args), encodePathTemplateSegment);
  const pathSegment = values.join('');
  return pathSegment;
}
function encodePathTemplateSegment(value) {
  let skipEncode = false;
  const encode = m => skipEncode ? m.toString() : encodeURIComponent(m);
  if (value instanceof SkipEncode) {
    value = value.value;
    skipEncode = true;
  }
  return Array.isArray(value) ? value.map(encode).join('/') : [encode(value)];
}
function interweaveArrays(a, b) {
  const min = Math.min(a.length, b.length);
  return Array.apply(null, new Array(min)).reduce((result, _, index) => {
    result.push(a[index], b[index]);
    return result;
  }, []).concat((a.length > min ? a : b).slice(min));
}

/**
 * Thrown when one or more arguments passed to a method fail validation.
 */
class ArgumentsValidationError extends Error {
  constructor(errors) {
    const errorKeys = Object.keys(errors);
    let message;
    if (errorKeys.length === 0) {
      message = 'One or more arguments failed validation.';
    } else if (errorKeys.length === 1 && errors[errorKeys[0]].length === 1) {
      message = `Argument for '${errorKeys[0]}' failed validation.\n\n${errors[errorKeys[0]][0].message}`;
    } else {
      message = `The following arguments failed validation: ${errorKeys.join(', ')}.\n\n`;
      const msgList = [];
      for (const param of errorKeys) {
        msgList.push(`> For argument '${param}':`);
        if (errors[param].length === 1) {
          msgList.push(errors[param][0].message);
        } else {
          for (let index = 0; index < errors[param].length; index++) {
            const error = errors[param][index];
            msgList.push(`>> Issue #${index + 1}\n\n${error.message}`);
          }
        }
      }
      message += msgList.join('\n\n');
    }
    super(message);
    this.errors = errors;
  }
}

/**
 * Thrown when the API response does not match the schema.
 */
class ResponseValidationError extends Error {
  constructor(apiResponse, errors) {
    let message = 'The response did not match the response schema.';
    if (errors.length === 1) {
      message += `\n\n${errors[0].message}`;
    } else {
      message += errors.map((e, i) => `\n\n> Issue #${i + 1}\n\n${e.message}`).join('');
    }
    super(message);
    this.request = apiResponse.request;
    this.statusCode = apiResponse.statusCode;
    this.headers = apiResponse.headers;
    this.body = apiResponse.body;
    this.errors = errors;
  }
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Prepares arguments for being sent in the API request.
 *
 * Each argument is validated and converted to a JSON-serialization ready value.
 *
 * If one or more arguments fail validation, an ArgumentsValidationError is
 * thrown, which contains the validation details for all arguments that failed
 * validation.
 *
 * @param params Map of arguments with values and schema
 * @returns Map of serialization-ready argument values
 *
 * @throws ArgumentsValidationError
 */
function prepareArgs(params) {
  const validationErrors = {};
  const result = {};
  for (const paramName in params) {
    if (Object.prototype.hasOwnProperty.call(params, paramName)) {
      const paramInfo = params[paramName];
      const validationResult = validateAndUnmap(paramInfo[0], paramInfo[1]);
      if (validationResult.errors) {
        validationErrors[paramName] = validationResult.errors;
      } else {
        result[paramName] = validationResult.result;
      }
    }
  }
  if (Object.keys(validationErrors).length > 0) {
    throw new ArgumentsValidationError(validationErrors);
  }
  return result;
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
function xmlSerialize(_rootName, _value) {
  throw new Error('XML serialization is not available.');
}
async function xmlDeserialize(_rootName, _xmlString) {
  throw new Error('XML deserialization is not available.');
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const JSON = /*#__PURE__*/JSONBig({
  useNativeBigInt: true
});
class DefaultRequestBuilder {
  constructor(_httpClient, _baseUrlProvider, _apiErrorFactory, _authenticationProvider, _httpMethod, _path) {
    this._httpClient = _httpClient;
    this._baseUrlProvider = _baseUrlProvider;
    this._apiErrorFactory = _apiErrorFactory;
    this._authenticationProvider = _authenticationProvider;
    this._httpMethod = _httpMethod;
    this._path = _path;
    this._headers = {};
    this._query = [];
    this._interceptors = [];
    this._validateResponse = true;
    this._addResponseValidator();
    this._addAuthentication();
    this.prepareArgs = prepareArgs.bind(this);
  }
  authenticate(params) {
    this._authParams = params;
  }
  deprecated(methodName, message) {
    deprecated(methodName, message);
  }
  appendTemplatePath(strings, ...args) {
    const pathSegment = pathTemplate(strings, ...args);
    this.appendPath(pathSegment);
  }
  method(httpMethodName) {
    this._httpMethod = httpMethodName;
  }
  baseUrl(arg) {
    this._baseUrlArg = arg;
  }
  appendPath(path) {
    this._path = this._path ? mergePath(this._path, path) : path;
  }
  acceptJson() {
    this._accept = JSON_CONTENT_TYPE;
  }
  accept(acceptHeaderValue) {
    this._accept = acceptHeaderValue;
  }
  contentType(contentTypeHeaderValue) {
    this._contentType = contentTypeHeaderValue;
  }
  header(name, value) {
    if (value === undefined) {
      return;
    }
    setHeader(this._headers, name, value.toString());
  }
  headers(headersToMerge) {
    mergeHeaders(this._headers, headersToMerge);
  }
  query(nameOrParameters, value) {
    if (nameOrParameters === null || nameOrParameters === undefined) return;
    const queryString = typeof nameOrParameters === 'string' ? urlEncodeObject({
      [nameOrParameters]: value
    }) : urlEncodeObject(nameOrParameters);
    if (queryString) {
      this._query.push(queryString);
    }
  }
  text(body) {
    this._body = body;
    this._setContentTypeIfNotSet(TEXT_CONTENT_TYPE);
  }
  json(data) {
    this._body = JSON.stringify(data);
    this._setContentTypeIfNotSet(JSON_CONTENT_TYPE);
  }
  xml(argName, data, rootName, schema) {
    const mappingResult = validateAndUnmapXml(data, schema);
    if (mappingResult.errors) {
      throw new ArgumentsValidationError({
        [argName]: mappingResult.errors
      });
    }
    this._body = xmlSerialize();
    this._setContentTypeIfNotSet(XML_CONTENT_TYPE);
  }
  stream(file) {
    this._stream = file;
  }
  form(parameters) {
    this._form = filterFileWrapperFromKeyValuePairs(formDataEncodeObject(parameters));
  }
  formData(parameters) {
    this._formData = formDataEncodeObject(parameters);
  }
  toRequest() {
    const request = {
      method: this._httpMethod,
      url: mergePath(this._baseUrlProvider(this._baseUrlArg), this._path)
    };
    if (this._query.length > 0) {
      const queryString = this._query.join('&');
      request.url += (request.url.indexOf('?') === -1 ? '?' : '&') + queryString;
    }
    request.url = sanitizeUrl(request.url);
    // defensively copy headers
    const headers = {
      ...this._headers
    };
    if (this._accept) {
      setHeader(headers, ACCEPT_HEADER, this._accept);
    }
    if (this._contentType) {
      setHeader(headers, CONTENT_TYPE_HEADER, this._contentType);
    }
    setHeader(headers, CONTENT_LENGTH_HEADER);
    request.headers = headers;
    if (this._body !== undefined) {
      request.body = {
        type: 'text',
        content: this._body
      };
    } else if (this._form !== undefined) {
      request.body = {
        type: 'form',
        content: this._form
      };
    } else if (this._formData !== undefined) {
      request.body = {
        type: 'form-data',
        content: this._formData
      };
    } else if (this._stream !== undefined) {
      request.body = {
        type: 'stream',
        content: this._stream
      };
    }
    return request;
  }
  intercept(interceptor) {
    this._interceptors.push(interceptor);
  }
  interceptRequest(interceptor) {
    this.intercept((req, opt, next) => next(interceptor(req), opt));
  }
  interceptResponse(interceptor) {
    this.intercept(async (req, opt, next) => interceptor(await next(req, opt)));
  }
  defaultToError(apiErrorCtor) {
    this._apiErrorFactory = apiErrorCtor;
  }
  validateResponse(validate) {
    this._validateResponse = validate;
  }
  throwOn(statusCode, errorConstructor, ...args) {
    this.interceptResponse(context => {
      const {
        response
      } = context;
      if (typeof statusCode === 'number' && response.statusCode === statusCode || typeof statusCode !== 'number' && response.statusCode >= statusCode[0] && response.statusCode <= statusCode[1]) {
        throw new errorConstructor(context, ...args);
      }
      return context;
    });
  }
  async call(requestOptions) {
    // Prepare the HTTP pipeline
    const pipeline = callHttpInterceptors(this._interceptors, async (request, opt) => {
      const response = await this._httpClient(request, opt);
      return {
        request,
        response
      };
    });
    // Execute HTTP pipeline
    const {
      request,
      response
    } = await pipeline(this.toRequest(), requestOptions);
    return {
      ...response,
      request,
      result: undefined
    };
  }
  async callAsText(requestOptions) {
    const result = await this.call(requestOptions);
    if (typeof result.body !== 'string') {
      throw new Error('Could not parse body as string.'); // TODO: Replace with SDK error
    }

    return {
      ...result,
      result: result.body
    };
  }
  async callAsOptionalText(requestOptions) {
    const result = await this.call(requestOptions);
    if (typeof result.body !== 'string') {
      return {
        ...result,
        result: undefined
      };
    }
    return {
      ...result,
      result: result.body
    };
  }
  async callAsStream(requestOptions) {
    this.interceptRequest(req => ({
      ...req,
      responseType: 'stream'
    }));
    const result = await this.call(requestOptions);
    return {
      ...result,
      result: convertToStream(result.body)
    };
  }
  async callAsJson(schema, requestOptions) {
    this.interceptRequest(request => {
      const headers = {
        ...request.headers
      };
      setHeaderIfNotSet(headers, ACCEPT_HEADER, JSON_CONTENT_TYPE);
      return {
        ...request,
        headers
      };
    });
    const result = await this.call(requestOptions);
    if (result.body === '') {
      throw new Error('Could not parse body as JSON. The response body is empty.');
    }
    if (typeof result.body !== 'string') {
      throw new Error('Could not parse body as JSON. The response body is not a string.');
    }
    let parsed;
    try {
      parsed = JSON.parse(result.body);
    } catch (error) {
      throw new Error(`Could not parse body as JSON.\n\n${error.message}`);
    }
    const mappingResult = validateAndMap(parsed, schema);
    if (mappingResult.errors) {
      throw new ResponseValidationError(result, mappingResult.errors);
    }
    return {
      ...result,
      result: mappingResult.result
    };
  }
  async callAsXml(rootName, schema, requestOptions) {
    this.interceptRequest(request => {
      const headers = {
        ...request.headers
      };
      setHeaderIfNotSet(headers, ACCEPT_HEADER, XML_CONTENT_TYPE);
      return {
        ...request,
        headers
      };
    });
    const result = await this.call(requestOptions);
    if (result.body === '') {
      throw new Error('Could not parse body as XML. The response body is empty.');
    }
    if (typeof result.body !== 'string') {
      throw new Error('Could not parse body as XML. The response body is not a string.');
    }
    let xmlObject;
    try {
      xmlObject = await xmlDeserialize(rootName, result.body);
    } catch (error) {
      throw new Error(`Could not parse body as XML.\n\n${error.message}`);
    }
    const mappingResult = validateAndMapXml(xmlObject, schema);
    if (mappingResult.errors) {
      throw new ResponseValidationError(result, mappingResult.errors);
    }
    return {
      ...result,
      result: mappingResult.result
    };
  }
  _setContentTypeIfNotSet(contentType) {
    if (!this._contentType) {
      setHeaderIfNotSet(this._headers, CONTENT_TYPE_HEADER, contentType);
    }
  }
  _addResponseValidator() {
    this.interceptResponse(context => {
      const {
        response
      } = context;
      if (this._validateResponse && (response.statusCode < 200 || response.statusCode >= 300)) {
        throw new this._apiErrorFactory(context, `Response status code was not ok: ${response.statusCode}.`);
      }
      return context;
    });
  }
  _addAuthentication() {
    this.intercept((...args) => {
      const handler = this._authenticationProvider(this._authParams);
      return handler(...args);
    });
  }
}
function createRequestBuilderFactory(httpClient, baseUrlProvider, apiErrorFactory, authenticationProvider) {
  return (httpMethod, path) => {
    return new DefaultRequestBuilder(httpClient, baseUrlProvider, apiErrorFactory, authenticationProvider, httpMethod, path);
  };
}
function mergePath(left, right) {
  if (!right || right === '') {
    return left;
  }
  if (left[left.length - 1] === '/' && right[0] === '/') {
    return left + right.substr(1);
  } else if (left[left.length - 1] === '/' || right[0] === '/') {
    return left + right;
  } else {
    return `${left}/${right}`;
  }
}
function convertToStream(content) {
  if (typeof content !== 'string') {
    return content;
  }
  if (isNode) {
    // ref: https://stackoverflow.com/a/22085851
    const rs = new (require('stream').Readable)();
    rs._read = () => {};
    rs.push(content);
    rs.push(null);
    return rs;
  }
  return new Blob([content]);
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const USER_AGENT = 'node-messaging';
class Client {
  constructor(config) {
    this._config = {
      ...DEFAULT_CONFIGURATION,
      ...config
    };
    this._requestBuilderFactory = createRequestHandlerFactory(server => getBaseUri(server, this._config), basicAuthAuthenticationProvider(this._config), new HttpClient({
      timeout: this._config.timeout,
      clientConfigOverrides: this._config.unstable_httpClientOptions
    }), [withErrorHandlers, withUserAgent, withAuthenticationByDefault]);
  }
  getRequestBuilderFactory() {
    return this._requestBuilderFactory;
  }
  /**
   * Clone this client and override given configuration options
   */
  withConfiguration(config) {
    return new Client({
      ...this._config,
      ...config
    });
  }
}
function createHttpClientAdapter(client) {
  return async (request, requestOptions) => {
    return await client.executeRequest(request, requestOptions);
  };
}
function getBaseUri(server = 'MessagingDefault', config) {
  if (config.environment === Environment.Production) {
    if (server === 'MessagingDefault') {
      return 'https://messaging.bandwidth.com/api/v2';
    }
  }
  if (config.environment === Environment.Custom) {
    if (server === 'MessagingDefault') {
      return pathTemplate`${new SkipEncode(config.baseUrl)}`;
    }
  }
  throw new Error('Could not get Base URL. Invalid environment or server.');
}
function createRequestHandlerFactory(baseUrlProvider, authProvider, httpClient, addons) {
  const requestBuilderFactory = createRequestBuilderFactory(createHttpClientAdapter(httpClient), baseUrlProvider, ApiError, authProvider);
  return tap(requestBuilderFactory, ...addons);
}
function tap(requestBuilderFactory, ...callback) {
  return (...args) => {
    const requestBuilder = requestBuilderFactory(...args);
    callback.forEach(c => c(requestBuilder));
    return requestBuilder;
  };
}
function withErrorHandlers(rb) {
  rb.defaultToError(ApiError);
}
function withUserAgent(rb) {
  rb.header('user-agent', USER_AGENT);
}
function withAuthenticationByDefault(rb) {
  rb.authenticate(true);
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
class MessagingExceptionError extends ApiError {}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const bandwidthMessageSchema = /*#__PURE__*/object({
  id: ['id', /*#__PURE__*/optional( /*#__PURE__*/string())],
  owner: ['owner', /*#__PURE__*/optional( /*#__PURE__*/string())],
  applicationId: ['applicationId', /*#__PURE__*/optional( /*#__PURE__*/string())],
  time: ['time', /*#__PURE__*/optional( /*#__PURE__*/string())],
  segmentCount: ['segmentCount', /*#__PURE__*/optional( /*#__PURE__*/number())],
  direction: ['direction', /*#__PURE__*/optional( /*#__PURE__*/string())],
  to: ['to', /*#__PURE__*/optional( /*#__PURE__*/array( /*#__PURE__*/string()))],
  from: ['from', /*#__PURE__*/optional( /*#__PURE__*/string())],
  media: ['media', /*#__PURE__*/optional( /*#__PURE__*/array( /*#__PURE__*/string()))],
  text: ['text', /*#__PURE__*/optional( /*#__PURE__*/string())],
  tag: ['tag', /*#__PURE__*/optional( /*#__PURE__*/string())],
  priority: ['priority', /*#__PURE__*/optional( /*#__PURE__*/string())]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const bandwidthMessageItemSchema = /*#__PURE__*/object({
  messageId: ['messageId', /*#__PURE__*/optional( /*#__PURE__*/string())],
  accountId: ['accountId', /*#__PURE__*/optional( /*#__PURE__*/string())],
  sourceTn: ['sourceTn', /*#__PURE__*/optional( /*#__PURE__*/string())],
  destinationTn: ['destinationTn', /*#__PURE__*/optional( /*#__PURE__*/string())],
  messageStatus: ['messageStatus', /*#__PURE__*/optional( /*#__PURE__*/string())],
  messageDirection: ['messageDirection', /*#__PURE__*/optional( /*#__PURE__*/string())],
  messageType: ['messageType', /*#__PURE__*/optional( /*#__PURE__*/string())],
  segmentCount: ['segmentCount', /*#__PURE__*/optional( /*#__PURE__*/number())],
  errorCode: ['errorCode', /*#__PURE__*/optional( /*#__PURE__*/number())],
  receiveTime: ['receiveTime', /*#__PURE__*/optional( /*#__PURE__*/string())],
  carrierName: ['carrierName', /*#__PURE__*/nullable( /*#__PURE__*/optional( /*#__PURE__*/string()))]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const pageInfoSchema = /*#__PURE__*/object({
  prevPage: ['prevPage', /*#__PURE__*/optional( /*#__PURE__*/string())],
  nextPage: ['nextPage', /*#__PURE__*/optional( /*#__PURE__*/string())],
  prevPageToken: ['prevPageToken', /*#__PURE__*/optional( /*#__PURE__*/string())],
  nextPageToken: ['nextPageToken', /*#__PURE__*/optional( /*#__PURE__*/string())]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const bandwidthMessagesListSchema = /*#__PURE__*/object({
  totalCount: ['totalCount', /*#__PURE__*/optional( /*#__PURE__*/number())],
  pageInfo: ['pageInfo', /*#__PURE__*/optional( /*#__PURE__*/lazy(() => pageInfoSchema))],
  messages: ['messages', /*#__PURE__*/optional( /*#__PURE__*/array( /*#__PURE__*/lazy(() => bandwidthMessageItemSchema)))]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const mediaSchema = /*#__PURE__*/object({
  content: ['content', /*#__PURE__*/optional( /*#__PURE__*/string())],
  contentLength: ['contentLength', /*#__PURE__*/optional( /*#__PURE__*/number())],
  mediaName: ['mediaName', /*#__PURE__*/optional( /*#__PURE__*/string())]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/**
 * Enum for PriorityEnum
 */
var PriorityEnum;
(function (PriorityEnum) {
  PriorityEnum["Default"] = "default";
  PriorityEnum["High"] = "high";
})(PriorityEnum || (PriorityEnum = {}));
/**
 * Schema for PriorityEnum
 */
const priorityEnumSchema = /*#__PURE__*/stringEnum(PriorityEnum);

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
const messageRequestSchema = /*#__PURE__*/object({
  applicationId: ['applicationId', /*#__PURE__*/string()],
  to: ['to', /*#__PURE__*/array( /*#__PURE__*/string())],
  from: ['from', /*#__PURE__*/string()],
  text: ['text', /*#__PURE__*/optional( /*#__PURE__*/string())],
  media: ['media', /*#__PURE__*/optional( /*#__PURE__*/array( /*#__PURE__*/string()))],
  tag: ['tag', /*#__PURE__*/optional( /*#__PURE__*/string())],
  priority: ['priority', /*#__PURE__*/optional(priorityEnumSchema)]
});

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
/** Base class for all controllers */
class BaseController {
  constructor(client) {
    this.createRequest = client.getRequestBuilderFactory();
  }
}

/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
class ApiController extends BaseController {
  /**
   * listMedia
   *
   * @param accountId          User's account ID
   * @param continuationToken  Continuation token used to retrieve subsequent media.
   * @return Response from the API call
   */
  async listMedia(accountId, continuationToken, requestOptions) {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      continuationToken: [continuationToken, optional(string())]
    });
    req.header('Continuation-Token', mapped.continuationToken);
    req.appendTemplatePath`/users/${mapped.accountId}/media`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(array(mediaSchema), requestOptions);
  }
  /**
   * getMedia
   *
   * @param accountId User's account ID
   * @param mediaId   Media ID to retrieve
   * @return Response from the API call
   */
  async getMedia(accountId, mediaId, requestOptions) {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      mediaId: [mediaId, string()]
    });
    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsStream(requestOptions);
  }
  /**
   * uploadMedia
   *
   * @param accountId     User's account ID
   * @param mediaId       The user supplied custom media ID
   * @param body
   * @param contentType   The media type of the entity-body
   * @param cacheControl  General-header field is used to specify directives that MUST be obeyed by all
   *                                     caching mechanisms along the request/response chain.
   * @return Response from the API call
   */
  async uploadMedia(accountId, mediaId, body, contentType, cacheControl, requestOptions) {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      mediaId: [mediaId, string()],
      contentType: [contentType, optional(string())],
      cacheControl: [cacheControl, optional(string())]
    });
    req.header('Content-Type', mapped.contentType);
    req.header('Cache-Control', mapped.cacheControl);
    req.stream(body);
    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.call(requestOptions);
  }
  /**
   * deleteMedia
   *
   * @param accountId User's account ID
   * @param mediaId   The media ID to delete
   * @return Response from the API call
   */
  async deleteMedia(accountId, mediaId, requestOptions) {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      mediaId: [mediaId, string()]
    });
    req.appendTemplatePath`/users/${mapped.accountId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.call(requestOptions);
  }
  /**
   * getMessages
   *
   * @param accountId     User's account ID
   * @param messageId     The ID of the message to search for. Special characters need to be encoded using
   *                                URL encoding
   * @param sourceTn      The phone number that sent the message
   * @param destinationTn The phone number that received the message
   * @param messageStatus The status of the message. One of RECEIVED, QUEUED, SENDING, SENT, FAILED,
   *                                DELIVERED, ACCEPTED, UNDELIVERED
   * @param errorCode     The error code of the message
   * @param fromDateTime  The start of the date range to search in ISO 8601 format. Uses the message receive
   *                                time. The date range to search in is currently 14 days.
   * @param toDateTime    The end of the date range to search in ISO 8601 format. Uses the message receive
   *                                time. The date range to search in is currently 14 days.
   * @param pageToken     A base64 encoded value used for pagination of results
   * @param limit         The maximum records requested in search result. Default 100. The sum of limit and
   *                                after cannot be more than 10000
   * @return Response from the API call
   */
  async getMessages(accountId, messageId, sourceTn, destinationTn, messageStatus, errorCode, fromDateTime, toDateTime, pageToken, limit, requestOptions) {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      messageId: [messageId, optional(string())],
      sourceTn: [sourceTn, optional(string())],
      destinationTn: [destinationTn, optional(string())],
      messageStatus: [messageStatus, optional(string())],
      errorCode: [errorCode, optional(number())],
      fromDateTime: [fromDateTime, optional(string())],
      toDateTime: [toDateTime, optional(string())],
      pageToken: [pageToken, optional(string())],
      limit: [limit, optional(number())]
    });
    req.query('messageId', mapped.messageId);
    req.query('sourceTn', mapped.sourceTn);
    req.query('destinationTn', mapped.destinationTn);
    req.query('messageStatus', mapped.messageStatus);
    req.query('errorCode', mapped.errorCode);
    req.query('fromDateTime', mapped.fromDateTime);
    req.query('toDateTime', mapped.toDateTime);
    req.query('pageToken', mapped.pageToken);
    req.query('limit', mapped.limit);
    req.appendTemplatePath`/users/${mapped.accountId}/messages`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(bandwidthMessagesListSchema, requestOptions);
  }
  /**
   * createMessage
   *
   * @param accountId User's account ID
   * @param body
   * @return Response from the API call
   */
  async createMessage(accountId, body, requestOptions) {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, string()],
      body: [body, messageRequestSchema]
    });
    req.json(mapped.body);
    req.appendTemplatePath`/users/${mapped.accountId}/messages`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(bandwidthMessageSchema, requestOptions);
  }
}

export { AbortError, ApiController, ApiError, ArgumentsValidationError, Client, DEFAULT_CONFIGURATION, Environment, FileWrapper, PriorityEnum, ResponseValidationError, cloneFileWrapper, isFileWrapper };
//# sourceMappingURL=messaging.esm.js.map
