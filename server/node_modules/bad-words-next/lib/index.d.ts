/**
 * Simple key-value object for homoglyphs conversion
 */
export type Lookalike = Record<string | number, string>;
/**
 * Placeholder mode to either replace with or repeat the placeholder
 * @type {String}
 */
export type PlaceholderMode = 'repeat' | 'replace';
/**
 * Dictionary data format
 */
export interface Data {
    /**
     * Unique dictionary ID
     * @type {string}
     */
    id: string;
    /**
     * Words list
     * @type {string[]}
     */
    words: string[];
    /**
     * Lookalike homoglyphs map
     * @type {Lookalike}
     */
    lookalike: Lookalike;
}
/**
 * Constructor options
 */
export interface Options {
    /**
     * Dictionary data
     * @type {[type]}
     */
    data?: Data;
    /**
     * Filter placeholder
     * @defaultValue <code>'***'</code>
     * @type {[type]}
     */
    placeholder?: string;
    /**
     * Placeholder mode to either replace with or repeat the placeholder
     * @defaultValue <code>'replace'</code>
     * @type {[type]}
     */
    placeholderMode?: PlaceholderMode;
    /**
     * Special chars to allow on start and/or end of a word
     * @defaultValue <code>/\d|[!@#$%^&*()[\\];:'",.?\\-_=+~`|]|a|(?:the)|(?:el)|(?:la)/</code>
     * @type {[type]}
     */
    specialChars?: RegExp;
    /**
     * Pseudo space chars, a list of values for `_` symbol replacement in a dictionary word string
     * @defaultValue <code>['', '.', '-', ';', '|']</code>
     */
    spaceChars?: string[];
    /**
     *  List of dictionary ids to apply transformations from [confusables](https://github.com/gc/confusables) npm package
     *  @defaultValue <code>['en', 'es', 'de', 'ru_lat']</code>
     */
    confusables?: string[];
    /**
     * Max items to store in the internal cache
     * @defaultValue 100
     * @type {[type]}
     */
    maxCacheSize?: number;
    /**
     * The list of exclusions
     */
    exclusions?: string[];
}
/**
 * Internal options with required properties
 */
interface InternalOptions {
    data?: Data;
    placeholder: string;
    placeholderMode: PlaceholderMode;
    specialChars: RegExp;
    spaceChars: string[];
    confusables: string[];
    maxCacheSize: number;
    exclusions: string[];
}
/**
 * Internal dictionaries data format
 */
interface InternalData extends Data {
    /**
     * Regular expression for dictionary words
     * @type {RegExp}
     */
    wordsRegexp: RegExp;
    /**
     * Regular expression for lookalikes
     * @type {RegExp}
     */
    lookalikeRegexp?: RegExp;
}
/**
 * Internal dictionaries data map
 */
type InternalDataMap = Record<string, InternalData>;
/**
 * Main library class implementing profanity filtering and detection
 */
declare class BadWordsNext {
    /**
     * Options object built from options passed into constructor and default options object
     * @private
     * @type {InternalOptions}
     */
    opts: InternalOptions;
    /**
     * Special chars represented as a string from specialChars regular expression
     * @private
     * @type {string}
     */
    specialChars: string;
    /**
     * Prepared regexps for exclusions
     * @private
     * @type {RegExp[]}
     */
    exclusionsRegexps: RegExp[];
    /**
     * Dictionaries ids list
     * @private
     * @type {string[]}
     */
    ids: string[];
    /**
     * Dictionaries data map with data ID as a key
     * @private
     * @type {InternalDataMap}
     */
    data: InternalDataMap;
    /**
     * Clear memoized check
     * @private
     * @type {() => void}
     */
    clear: () => void;
    /**
     * Create an instance of BadWordsNext class
     *
     * @param {Options}
     */
    constructor(opts?: Options);
    /**
     * Add dictionary data for bad words filtering and detection
     *
     * @param {Data} data Dictionary data
     */
    add(data: Data): void;
    /**
     * Prepare a string by replacing dictionary lookalikes and confusables
     *
     * @private
     * @param  {string} str input string
     * @param  {string} id dictionary ID
     * @return {string}
     */
    prepare(str: string, id: string): string;
    /**
     * Create new regular expression by dictionary expression string
     *
     * @private
     * @param  {string}
     * @return {RegExp}
     */
    regexp(expr: string): RegExp;
    /**
     * Check whether the input string contains bad words or not.
     * Note: it does not take into account the exclusions list.
     *
     * @private
     * @param {string} str
     * @return {boolean}
     */
    preCheck(str: string): boolean;
    /**
     * Check whether the particular word is bad or not
     *
     * @param {string} word
     * @return {boolean}
     */
    check(word: string): boolean;
    /**
     * Filter bad words in the input string and replace them with a placeholder
     *
     * @param  {string}
     * @param  {(badword: string) => void}
     * @return {string}
     */
    filter(str: string, onCatch?: (badword: string) => void): string;
}
export default BadWordsNext;
