// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          Int     @id @default(autoincrement())
  username                    String  @unique
  email                       String? @unique
  password                    String
  phoneNumber                 String? @db.VarChar(32)
  preferredLanguage           String  @default("en")
  allowExplicitContent        Boolean @default(true)
  showOriginalWithTranslation Boolean @default(true)
  role                        String  @default("USER")
  enableAIResponder           Boolean @default(false)

  // Encryption key
  publicKey  String? // for E2EE
  privateKey String? // (optional for now — may not store this in DB)

  // Relations
  messages          Message[]        @relation("UserMessages") // Messages sent by the user
  participants      Participant[] // User's membership in chat rooms
  reports           Report[]         @relation("UserReports") // NEW backreference
  randomChatRooms   RandomChatRoom[] @relation("RandomChatParticipants") // For random chat pairing
  autoDeleteSeconds Int?
  showReadReceipts  Boolean          @default(true)
  readMessages      Message[]        @relation("ReadMessages")
  avatarUrl         String?
  emojiTag          String?

  // ✅ New backrelations
  contactsOwned Contact[] @relation("ContactsOwned")
  contactsSaved Contact[] @relation("ContactsSaved")

  auditLogs AuditLog[] @relation("AuditActor")
}

model ChatRoom {
  id        Int      @id @default(autoincrement())
  name      String?
  isGroup   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participants Participant[] // Users in this chatroom (via join table)
  messages     Message[]     @relation("ChatRoomMessages") // Standard chat messages
}

model Participant {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id])
  chatRoomId Int
  joinedAt   DateTime @default(now())

  @@unique([userId, chatRoomId]) // Each user can only be in a chatroom once
}

model Message {
  id Int @id @default(autoincrement())

  // Encrypted content (new)
  contentCiphertext String // AES-encrypted message body
  encryptedKeys     Json // { [userId: string]: base64([nonce|box]) }

  rawContent        String
  translatedContent String?
  translatedFrom    String?
  translatedTo      String?
  isExplicit        Boolean   @default(false)
  imageUrl          String?
  expiresAt         DateTime?
  deletedBySender   Boolean   @default(false)

  // Relations
  sender   User @relation("UserMessages", fields: [senderId], references: [id])
  senderId Int

  chatRoom   ChatRoom @relation("ChatRoomMessages", fields: [chatRoomId], references: [id])
  chatRoomId Int

  // Optional random chat relation
  randomChatRoomId Int?
  randomChatRoom   RandomChatRoom? @relation(fields: [randomChatRoomId], references: [id])

  createdAt DateTime @default(now())
  readBy    User[]   @relation("ReadMessages")
  reports   Report[]
}

model RandomChatRoom {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Users connected for random chat
  participants User[] @relation("RandomChatParticipants")

  // Messages sent in this random chat
  messages  Message[]
  aiEnabled Boolean   @default(false) // Per-chat toggle for AI bot
}

model Contact {
  id Int @id @default(autoincrement())

  // Owner (the person who saved the contact)
  ownerId Int
  owner   User @relation("ContactsOwned", fields: [ownerId], references: [id], onDelete: Cascade)

  // Linked app user (optional)
  userId Int?
  user   User? @relation("ContactsSaved", fields: [userId], references: [id])

  // External contact fields (for people who don't have an account yet)
  externalPhone String? @db.VarChar(32)
  externalName  String?

  alias     String?
  favorite  Boolean  @default(false)
  createdAt DateTime @default(now())

  // Prevent duplicates for the owner:
  @@unique([ownerId, userId]) // ok even when userId is nullable (Postgres allows multiple NULLs)
  @@unique([ownerId, externalPhone])
  @@index([ownerId])
  @@index([userId])
}

model Report {
  id               Int      @id @default(autoincrement())
  messageId        Int
  reporterId       Int
  decryptedContent String
  createdAt        DateTime @default(now())

  message  Message @relation(fields: [messageId], references: [id])
  reporter User    @relation("UserReports", fields: [reporterId], references: [id])
}

model AuditLog {
  id      Int  @id @default(autoincrement())
  actorId Int
  actor   User @relation("AuditActor", fields: [actorId], references: [id], onDelete: Cascade)

  action     String // e.g., "users.list", "users.ban", "messages.delete"
  resource   String? // e.g., "user", "message", "chatroom"
  resourceId String? // string so we can store UUIDs or composite keys
  status     Int // HTTP status code of the request when logged
  ip         String?
  userAgent  String?
  metadata   Json? // optional redacted/structured context (never raw PII)
  createdAt  DateTime @default(now())

  @@index([actorId, createdAt])
  @@index([action, createdAt])
}
